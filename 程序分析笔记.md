[toc]



# 编译原理
## 编译过程
### 词法分析
**词法分析的任务就是将程序从字符串变成Token串。**
根据这句话来看，逐步解析。
#### 什么是Token?
下面这个表大致描述了token的种类，**关键字、标识符、分隔符、字面量、注释、空白字符等。**  
<img src="./assets/SPA/3.15-1.jpg" height="200"></img>

#### 如何去将字符串识别成Token
首先最基本的，从字符串中匹配出词，我们需要用到**正则文法**(上下文相关文法的一个子集，同时正则文法不等于正则表达式)。正则文法示例如下：

```
DecimalLiteral: IntegerLiteral '.' [0-9]*     # 匹配浮点数字面量
              | '.' [0-9]+
              | IntegerLiteral 
              ;
IntegerLiteral: '0' | [1-9] [0-9]* ;     # 匹配整数字面量
```
**因为涉及到文法，所以我们实现的过程中应该避免使用无脑的文法规则匹配方式，否则会有大量的栈回溯**
#### 如何避免栈回溯，提高token识别速度
这里用到**有限自动机**，有限自动机分为两种  
+ 确定性有限自动机：针对每个输入都会发生一次确定的迁移(DFA Determinisitic Finite-State Automata)
+ 非确定性有限自动机：某些状态下，针对一个输入可能会迁移到不止一个状态，甚至在没有任何输入下，也会从一个状态迁移到另一个状态(NFA Non-deterministic Finite-State Automata)
  + 任何一个NFA可以通过算法转换DFA   

<img src="./assets/SPA/3.15-2.jpg" height="200"></img>  


### 语法分析
### 语义分析

# 程序分析
## 1. 南大静态程序分析 
### 1.1 数据流分析
#### 1.1.1 中间表示
    为什么不拿源代码直接做静态分析？
    1. 是因为我们首先要保证代码的正确性，太贴近语法结构缺乏一致性，而且源代码语义更复杂一些，不利于优化。
    2. AST也是，其更high-level，且更贴近语法结构，而IR是接近机器代码且通常是独立于语言，可以将多种前端语言转成IR一并分析，像llvm ir一样。3. AST缺少控制流，IR包含了控制流信息。
**IR:Three-Address Code**
三地址码(3-Address-Code)通常没有统一格式，每个指令右边至多一个操作符，且每条3AC至多有三个地址(变量名、常量和编译器生成的临时变量)。
```
x = y bop z：双目运算并赋值，bop = binary operator
x = uop z：单目运算并赋值，uop = unary operator
x = y：直接赋值
goto L：无条件跳转，L = label
if x goto L：条件跳转
if x rop y goto L：包含了关系运算的条件跳转，rop = relational operator
```
**IR:Static Single Assignment**
静态单赋值(SSA),每一个变量名称只能被赋值一次，每次想要赋值都要更换名称，并引入phi函数来根据控制流选择最新的变量。**(SSA 要求的是在静态，即仅从代码文本层面可以看出的单一赋值，而非运行时只会被赋值一次。参考循环中phi的实现)**
__为什么使用SSA？__  
* 控制流信息间接集成到了独特变量名中
  * 有些对控制流不敏感的简化分析，可以用SSA
* 在 SSA 形式中，UD 链（Use-Define Chain）是十分明确的。变量的每一个使用点只有唯一一个定义可以到达。
  * 编译器在做常量传播、公共子表达式删除等优化之前，必须获取程序的 UD 链和 DU 链。显然，UD 链越简洁，越方便做编译优化。
* 目前成熟语言的编译器里用于做优化的IR都是符合SSA格式的，他的好处就是容易形成UD链
* 而且就思考一下，ssa形式更容易进行编译前的常量替换。而如果不使用ssa，可能就只能计算一个变量第一次被赋值为常量那点的变量状态。

__SSA的缺点？__
  * SSA会引入过多的变量和phi函数
  * SSA转换成机器代码会引入效率低下问题

__Basic Blocks & Control Flow Graphs__
控制流分析通常指的是构建控制流图(CFG)，并以CFG为基础结构进行静态分析  
CFG中每个节点都是一个基本块(控制流只能从块首进入，块末出)  
__构建基本块__
* 给定输入程序P
* 输出P的基本块
* 算法
  * 1.决定P的leaders
    * P的第一条指令为leader
    * P中跳转的目标指令是leader
    * 跳转指令的后一条指令为leader(想象汇编if语句)
  * 2.构建P的基本块
    * 一个leader到其后续直到下一个leader前的所有指令  

#### 1.1.2 数据流分析
__分析的核心：How Data Flows on CFG?__
如何对数据做抽象(+, -, 0 等)？
# 待定  
##### 1.1.2.1 数据流分析的预备知识  
__Input and Output States 输入输出状态__
- 每一条IR的执行都会使状态从**输入状态**变为新的**输出状态**
- 输入/输出状态与语句前/后的program point相关联  
<img src="./assets/SPA/3.11-1.png" height="150"></img> <img src="./assets/SPA/3.11-2.png" height="150"></img>   

数据流分析中，每一个program point都会关联一组数据流值，代表该点可观察的抽象的程序状态。   
__转移方程约束的概念__  
分析数据流有前向和后向两种：  
<img src="./assets/SPA/3.11-3.png" height="150"></img>   
**控制流约束的概念**

# 形式化方法
# 编程语言
## 1. Python
CPython解释器对Python源码的处理过程如下:
    源代码--(pgen.c)-->语法树--(ast.c)-->抽象语法树(AST)--(compile.c)-->控制流程图--(compile.c)-->字节码
### 1.1 Python AST标准库
[官方文档](https://docs.python.org/zh-cn/3/library/ast.html)   
[Green Tree Snakes - the missing Python AST docs](https://greentreesnakes.readthedocs.io/en/latest/#)介绍了更多标准库中没说明的AST细节     
ASDL(abstract syntax description language)抽象语法描述语言   
class ast.AST为所有节点类的基类，抽象语法定义的每个左侧符号都是定义了一个类，右侧对每个构造器也定义一个类，这些类都是继承于左侧定义的类。括号中都是该类所含有的属性。(带<b>?</b>的属性，标记为可选，可能是<b>None</b>，如果这些属性有0或多个则用<b>*</b>标记)   
python ast里面所有数据类型是没有类型可言的，只给出了基本的常量 元组 冻结集 等，其中还有一些继承的类被用作属性，比如**op**属性接收的就是如ast.UAdd ast.Usub ast.Not等类的实例化对象。   
#### 1.1.2 解析python AST   
**ast.parse**(source, filename='<unknown>', mode='exec', *, type_comments=False, feature_version=None)函数和**compile**(source, filename, mode,ast.PyCF_ONLY_AST)函数等价。    
其中**model**指定了编译代码的种类(exec,eval,single)，同时模式也决定了生成的AST的__根节点__，以及**type_comments**指定代码是否有类型标注(python语法增强,[PEP 484](https://www.python.org/dev/peps/pep-0484)和[PEP 526](https://www.python.org/dev/peps/pep-0526))  
__exec__ 普通的python代码可以直接用exec模式  
__eval__ 单个python表达式可以用eval模式  
__single__ 单个python语句或表达式可以用single模式  
The root of the AST depends on the mode parameter you pass to ast.parse(), and it must correspond to the mode parameter when you call compile(). 

compile()函数也能把AST转换成可执行代码对象，用**exec()**和__eval()__，但是如果之前修改了AST并修改错了，compile函数就会报错。
```python
>>> tree = ast.parse("print('hello world')")
>>> tree
<_ast.Module object at 0x9e3df6c>
>>> exec(compile(tree, filename="<ast>", mode="exec"))
hello world
```   

对应的还有**ast.unparse(ast_obj)**将ast转化为python代码，但是会有一些不同，比如没有编译器优化。   

**lineno和col_offset**
lineno和end_lineno是源代码跨度的第一行和最后一行编号，col_offset和end_col_offset是生成节点的第一个和最后一个token的相应的utf-8字节偏移量。
parse()函数解析出来的AST都会有上面的属性，但是我们自己创建的节点没有，所以当我们替换AST中的节点时，需要修复新建节点的位置信息。
目前有**三种方式**  
**ast.fix_missing_locations(node)** 函数递归的将父节点的位置信息（lineno以及col_offset）赋值给没有位置信息的子节点(这种方法处理较为粗糙，不如下面那个方法)
**ast.copy_location(new_node, node)** 将node的位置信息拷贝给new_node节点，并返回new_node节点。当我们将旧节点替换成一个新节点的时候，这种方法比较适用。  
**ast.increment_lineno(node, n=1)** 将node节点以及其所以子节点的行号加上n。  
#### 1.1.2 遍历python AST   
标准库提供了几种解析python AST的方法。   
**class ast.NodeVisitor 类**，这是个访问ast节点类的基类，其遍历整个AST树并调用每个node中找到的visitor函数，需要我们继承它并添加visitor函数。   
访问每个节点，默认实现为**self.visit_classname**方法，classname为要访问的节点的类名。    
其中还有个函数叫做**generic_visit(node)**，它是用来访问节点的子节点的，比如FunctionDef节点中的body可能会有其他操作节点(如，BinOp等)，那我们也要定义visit_BinOp(node)方法，并在visit_FunctionDef(node)中调用generic_visit(node)方法才能递归访问BinOp节点，否则就只会调用visit_FunctionDef(node)方法。比如下面这段代码：  
```python
def add(x, y):
    return x + y
```
其AST中会有FunctionDef还会有BinOp，所以我们定义：   
```python 
class CodeVisitor(ast.NodeVisitor):
    def visit_BinOp(self, node):# 这个函数的访问是由于 Visit_FunctionDef的先访问再generic_visit才访问的
        print('Bin')            # 如果Visit_FunctionDef中没有generic_visit的话，则这个函数是不会访问的
        if isinstance(node.op, ast.Add):
            node.op = ast.Sub()
            
        self.generic_visit(node) # 这也是为了便于访问BinOp节点的子节点，如果有的话
    
    def visit_FunctionDef(self, node):
        print('Function Name: %s'% node.name)
        self.generic_visit(node) # FunctionDef中还包含有 BinOp,因此会进去visit BinOP
```
访问代码AST则输出：   
```
Function Name: add
Bin
```
**注意，如果想要在traversal节点的过程中对节点apply changes，则需要使用NodeTransformer访问类**   
**class ast.NodeTransformer 类**，用于遍历AST，并允许修改节点。其遍历AST，并使用visitor方法的返回值去替换或移除旧节点，如果visitor方法返回值为**None**，则该节点被移除，否则将替换为返回值，返回值为原始节点时无需替换。    
同时，如果要访问子节点，仍然需要为子节点调用generic_visit()方法，并定义相关的visit_classname(node)方法。  
```python
class CodeTransformer(ast.NodeTransformer):
    def visit_BinOp(self, node):
        if isinstance(node.op, ast.Add):
            node.op = ast.Sub()
        self.generic_visit(node)
        return node

    def visit_FunctionDef(self, node):
        self.generic_visit(node) # 这里表示先去访问里面的children node        
        if node.name == 'add':
            node.name = 'sub'
        args_num = len(node.args.args)
        
        args_num = len(node.args.args)
        args = tuple([arg.arg for arg in node.args.args])
        print(str(args))
        func_log_stmt = ''.join(["print('calling func: %s', " % node.name, "'args:'", ", %s" * args_num % args ,')'])
        node.body.insert(0, ast.parse(func_log_stmt))
        
        #func_log_stmt = ''.join(["print 'calling func: %s', " % node.name, "'args:'", ", %s" * args_num % args])
        #node.body.insert(0, ast.parse(func_log_stmt))

        return node

    def visit_Name(self, node):
        replace = {'add': 'sub', 'x': 'a', 'y': 'b'}
        re_id = replace.get(node.id, None)
        node.id = re_id or node.id
        self.generic_visit(node)
        return node
    
    def visit_arg(self, node):
        self.generic_visit(node)
        replace = {'x':'a', 'y':'b'}
        node.arg = replace[node.arg]
        return node
```
#### 1.1.3 其他python AST标准库辅助函数   
**Inspecting nodes**
ast.iter_fields() 遍历节点的属性
ast.get_docstring() 获得FunctionDef ClassDef Module节点的docstring
ast.dump() 返回一个字符串，其中包含节点以及其子节点。See also the [pretty printer](https://bitbucket.org/takluyver/greentreesnakes/src/master/astpp.py) used in this guide.
#### 1.1.4 python AST的一些应用
[python AST应用](https://greentreesnakes.readthedocs.io/en/latest/manipulating.html)

## 2. LLVM  
### 2.1 LLVM概述与编译流程  
#### 2.1.1 GCC与LLVM编译流程比较  
**GCC**编译流程：  
<img src="./assets/SPA/3.13-1.jpg" height="150"></img>  
GCC的中间代码为GIMPLE,编译为目标平台机器代码之后，通过链接器才能执行。  
**LLVM**编译流程：     
<img src="./assets/SPA/3.13-2.jpg" height="150"></img>  
LLVM的中间代码为LLVM IR，其他都一样    
#### 2.1.2 LLVM的优势 
LLVM是高度模块化的，每一个模块都可以从LLVM项目中抽离出来单独使用，而GCC则是一个整体。   
LLVM拓展性高，LLVM有丰富的API，但是GCC拓展难度大。   
#### 2.1.3 LLVM一些指令
**编译**
```bash
clang -S -emit-llvm hello.cpp -o hello.ll # 生成llvm ir
clang -c -emit-llvm hello.cpp -o hello.bc # 生成llvm bytecode
```
**优化**
```bash
opt -load LLVMObfuscator.so -hlw -S hello.ll -o hello_opt.ll # 对llvm ir优化
```
-load 加载特定的LLVM Pass(集合，一般为so库)
-hlw 是LLVM Pass中自定义参数，用来指定用哪个Pass优化

### 2.2 LLVM IR
**[官方文档](https://llvm.org/docs/LangRef.html)**   
**代码编译为llvm ir有以下结构**   
<img src="./assets/SPA/3.13-6.jpg" height="150"></img>  

**IR指令分类：** 
<table ><tr><td bgcolor=#0D1117 ><font size="1" color="#a7cfe9">

+ 终结指令 Terminator instructions
  + ret 指令
    + ret <type\> <value\> ;返回特定类型返回值
    + ret void ;无返回值
      + ret i32 5
      + ret {i32, i8} {i32 4, i8 2} ;返回一个结构体
  + br(branch) ;分支指令
    + br i1 <cond\>, label <iftrue\>, label <iffalse\> ;有条件跳转
    + br label <dest\> ;无条件跳转
  + cmp 指令
    + icmp <cond\> <ty\> <op1\> <op2\> ;比较整数op1,op2，cond:eq(等),ne(不等),ugt(无符号大于)等
    + fcmp <cond\> <ty\> <op1\> <op2\> ;比较浮点数op1,op2，cond:oeq(ordered and equal),ueq(unordered or equal),false(必定不成立)，ordered的意思是两个op都不能为NAN，否则返回true
  + swtich 指令
    + switch <intty\> <value\>, label <defaultdest\> [ <intty\> <val\>, label <dest\> ...]
      + switch i32 %val, label %otherwise [ i32 0, label %onzero
                                            i32 1, label %onone
                                            i32 2, label %ontwo ]
+ 二元运算 Binary Operations
  + add 指令
    + add <ty\> <op1\>, <op2\>
  + sub 指令
    + sub <ty\> <op1\>, <op2\>
  + mul 指令
    + mul <ty\> <op1\>, <op2\>
  + udiv 指令(无符号)
    + udiv <ty\> <op1\>, <op2\>
    + udiv exact <ty\> <op1\>, <op2\> ;加了exact之后，op1必须为op2倍数，否则报错
  + sdiv (有符号) 同上
  + urem (无符号取余)
    + urem <ty\> <op1\>, <op2\> 
  + srem (有符号) 同上
+ 按位二元运算 Bitwise Binary Operations
  + shl 指令
    + shl <ty\> <op1\>, <op2\>
      + shl i32 4, %var ;4左移%var位bit
  + lshr 指令
    + lshr <ty\> <op1\>, <op2\> ;逻辑右移,左侧补零
  + ashr 指令
    + ashr <ty\> <op1\>, <op2\> ;算数右移,左侧根据符号补充内容
  + and 指令
    + and <ty\> <op1\>, <op2\>
  + or 指令
    + or <ty\> <op1\>, <op2\>
  + xor 指令
    + xor <ty\> <op1\>, <op2\> ;异或,变量和-1异或,相当于取反
+ 内存访问和寻址操作 Memory Access and Addressing Operations
  + alloca 指令
    + alloca <type\> [, <ty\> <NumElements\>] [, align <alignment\>] ;栈中分配sizeof(type)*NumElements字节的内存,alignment对齐,返回<type\>类型指针
      + alloca i32
      + alloca i32, i32 4, align 1024
  + store 指令
    + store <ty\> <value\>, <ty\>* <pointer\> ;向特定类型指针指向地址存储相同类型的数据
      + store i32 3, i32* %ptr
  + load 指令
    + load <ty\>, <ty\>* <pointer\> ;从特定类型的指针指向内存中读取特定类型的数据
      + load i32, i32* %ptr
+ 类型转换操作 Conversion Operations
  + trunc .. to 截断指令
    + trunc <ty1\> <value\> to <ty2\> ;将ty1类型变量截断位ty2类型变量
      + trunc i32 254 to i8
  + zext .. to 零拓展指令
    + zext <ty1\> <value\> to <ty2\> ;将ty1类型变量零拓展为ty2类型变量
  + sext .. to 符号位拓展指令
    + sext <ty1\> <value\> to <ty2\> ;将ty1类型变量符号拓展为ty类型变量
+ 其他操作 Other Operations 
  + phi 指令
    + phi <ty\> [ <val0\>, <lable0\>], ... ;
      + phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]
  + select 指令(三元运算符)
    + select i1 <cond\>, <ty\> <val1\>, <ty\> <val2\>
  + call 指令
    + call <ty\>|<fnty\> <fnptrval\>(<function args\>) ;函数调用
      + call i32 @test(i32 %args)
</font></td></tr></table>


### 2.3 LLVM Pass
**LLVM源代码结构**
LLVM由C++11开发,代码使用了大量C++特性以及C++ STL.
llvm/include/llvm下存放了llvm提供的一些公共头文件  
<img src="./assets/SPA/3.13-3.jpg" height="150"></img>   
llvm/lib下存放了llvm大部分源代码   
<img src="./assets/SPA/3.13-4.jpg" height="150"></img>    
llvm/lib/Transforms下存放了所有llvm pass源代码，其中有一些llvm自带的pass   
<img src="./assets/SPA/3.13-5.jpg" height="150"></img>  

#### 2.3.1 LLVM Pass编写 

**llvm pass三种编译方式** 
+ 与整个llvm一起重新编译，pass代码放到llvm/lib/Transforms中(时间长)
+ 通过CMake对pass单独编译(方便)
+ 使用命令行对pass单独编译(不好管理)

llvm有多种类型pass，ModulePass，FunctionPass，CallGraphPass，LoopPass等

在llvm中使用CMake参考[llvm cmake官方文档](https://llvm.org/docs/CMake.html#developing-llvm-passes-out-ofsource) 
**编写一个简单的 Function Pass**
Function Pass以函数为单位处理，其子类需要实现runOnFunction(Function &F)函数，pass运行时对程序中每个函数执行runOnFunction函数。
```c++
#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

namespace{
    class HelloWorld:public FunctionPass{
        public:
            static char ID;
            HelloWorld() : FunctionPass(ID) {};

            bool runOnFunction(Function &F);
    };
}

bool HelloWorld::runOnFunction(Function &F){
    //todo
    outs() << "Hello" <<F.getName() << "\n";
}

char HelloWorld::ID = 0;
// hlw 是opt使用时的参数
static RegisterPass<HelloWorld> X("hlw", "Pass描述：My first line of llvm pass");

```
#### 2.3.2 LLVM Pass常用API  
<img src="./assets/SPA/3.13-7.jpg" height="200"></img>   

##### 2.3.2.1 函数Function
```c++
F.getName() //获取函数名称
F.getEntryBlock() //获取入口块
//遍历函数F中的基本块
bool runOnFunction(Function &F){
    for(BasicBlock &BB : F){
        //do something with BB
    }
}
```
##### 2.3.2.2 基本块BasicBlock
```c++
BB.getName() //获取基本块名称
BB.getTerminator() //获取基本块终结指令
//基本块的克隆
//基本块的分裂
//基本块的移动
//基本块中指令的遍历
bool runOnFunction(Function &F){
    for(BasicBlock &BB : F){
        for(Instruction &I : BB){
            // do something with I
        }
    }
}
```
##### 2.3.2.3 指令Instruction
Instruction类有很多子类
<img src="./assets/SPA/3.13-8.jpg" height="200"></img>   

```c++
//指令的创建
//指令的删除
//指令的修改
//指令中操作数的遍历
bool runOnFunction(Function &F){
    for(BasicBlock &BB : F){
        for(Instruction &I : BB){
            for(int i = 0;i < I.getNumOperands(); i++){
                Value *V = I.getOperand(i);
            }
        }
    }
}
```
##### 2.3.2.4 值Value
所有可以被当作**指令操作数**的类型都是Value的子类
<img src="./assets/SPA/3.13-9.jpg" height="200"></img>

##### 2.3.2.5 输出流
LLVM中建议用outs(),errs(),dbgs()三个函数打印输出流
```c++
bool runOnFunction(Function &F){
    outs() << "Function: " << F.getName() << "\n";
    errs() << "something wrong: " << "\n";
    dbgs() << "Dbg: " << "\n";
}
```

#### 2.4 LLVM IR混淆
**几个基本思路** 
+ 以函数为单位：控制流平坦化
+ 以基本块为单位：虚假控制流
+ 以指令为单位：指令替代 