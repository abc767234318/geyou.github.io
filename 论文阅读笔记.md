#### markdown语法

**加粗**  *斜体*
**在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(<br>)。**

## 论文阅读杂项
**syntactic和semantic区别**：前者是语法上，后者是语义上，比如将一个字面量赋值给一个字面量，语法上是没问题的，但是语义上是有问题的，也就生成不了AST。

## 3.10 Scalpel: The Python Static Analysis Framework

#### core functions included in Scalpel    
##### Code Rewriter      
CR(Code Rewriter)被设计为支持系统化的对已有的python程序进行修改，以达到(1)简化程序便于静态分析和(2)优化或修改有问题的程序的目的。  
 
(1)集成了一个包含一组规则的数据库，规则指示了被匹配的代码如何进行转换。   
    比如，lambda语句可以被转换为函数，这样静态分析不用考虑lambda语句的影响，否则可能会把lambda语句视为赋值语句，进而将其视为局部变量。如：transforming x = lambda a: a + 10 to def x(a): return a + 10;
    另外一个好处是迭代，可以在静态分析结果简化了语义的基础上迭代调用规则。
    还有就是链式方法调用，如： f1().f2().f3()可以被分离为 x = f1(); y = x.f2(); z = y.f3()，，这样可以用来分离链式方法调用，从而加速静态分析性能。  
![](./assets/paper/3.10-1.jpg)      
(2)受soot的启发，用户可以用特定的回调函数实现转换，以根据他们特定的需求来优化python代码。(后续此功能可能用来自动修复python代码)    
##### Static Analysis Functions  
(1)CFG construction  
考虑到python类和函数定义的嵌套，集成了一个嵌套的数据结构来存储控制流图。     
(2)SSA representation     
(3)constant propagation    
(4)alias analysis   
(5)import graph construction    
(6)fully qualified name inferrer    
    fully-qualified names, which are dotted strings that can represent the path from the top-level module down to the object itself   
(7)call graph construction    
(8)type inference    

## 4.2 A Language-Independent Analysis Platform for Source Code



## 5.8 Finding the Dwarf: Recovering Precise Types from WebAssembly Binaries
#### 启发式算法
启发式算法（heuristic algorithm)是相对于最优化算法提出的。一个问题的最优算法求得该问题每个实例的最优解。启发式算法可以这样定义：一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。
启发式算法一般用于解决NP-hard问题，其中NP是指非确定性多项式。  
例如，著名的推销员旅行问题（Travel Saleman Problem or TSP）：假设一个推销员需要从南京出发，经过广州，北京，上海，…，等 n 个城市， 最后返回香港。 任意两个城市之间都有飞机直达，但票价不等。假设公司只给报销 C 元钱，问是否存在一个行程安排，使得他能遍历所有城市，而且总的路费小于 C？  
推销员旅行问题显然是 NP 的。因为如果你任意给出一个行程安排，可以很容易算出旅行总开销。但是，要想知道一条总路费小于 C 的行程是否存在，在最坏情况下，必须检查所有可能的旅行安排。  
启发式算法是相对于最优化算法提出的，是基于直观或者经验构造的算法，在可接受的开销（时间和空间）内给出待解决组合优化问题的一个可行解。 

**目前比较通用的启发式算法一般有模拟退火算法（SA）、遗传算法（GA）、蚁群算法（ACO）、人工神经网络（ANN）等。 **

It improves over prior work on learning-based type recovery by representing the types-to-predict in an expressive type language, which can describe a large number of complex types, instead of the fixed, and usually small type vocabulary used previously.

debug information can provide type labels for supervised training.

其他语言的类型预测神经网络训练方法各种各样，输入形式的不同，比如token序列，数据流图，与源码相关的自然语言等，还有不同的模型架构和训练方法，比如递归神经网络，transformers，图神经网络和无监督预训练等。
目前的学习方法有两个问题，一个是针对webassembly的没有，更重要的是之前的工作要么是关注如何表示预测类型的代码，要么是关注什么机器学习模型最适合。
现有的预测方法将类型预测归类为分类问题，由于分类问题无法适合大量类型，所以他们预测时只支持很少的类型。
SnowWhite核心技术时使用一种表达性语言来描述SnowWhite可以预测的类型，该语言支持基本类型，命名类型，复杂类型比如指针，数组，枚举等，以及上面所有类型的递归组合。

Given the type language, SnowWhite trains a model to predict types as a sequence of tokens. That is, we formulate the type prediction problem as a sequence prediction, and not a classification task. An important advantage of sequence prediction is that we do not have to artificially limit the number of types the model can choose from, but instead support (at least in principle) infinitely many types.

One core contribution of this work is to describe the types to predict using a type language that includes precise information about primitive types, nested types, const and signed-ness, and type names. Figure 3 gives a BNF grammar of the language.

#### 类型转换思路
相较于其他类型预测训练方法的预测的类型的局限性，他采用了一种上下文无关文法来表示各种类型。这样表示可以方便类型嵌套和组合。之前都是采用的类型分类训练方法，这次是序列预测问题
<div align=center>
    <img src="./assets/paper/5.9-1.png">
</div>


## 5.8 An Empirical Study of Bugs in WebAssembly Compilers

