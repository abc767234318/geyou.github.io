
# 1. WebAssembly 
## 1.1 wasm 概述 
wasm模块有三种格式，前两种是熟知的wasm和wat格式，而第三种为内存(in-memory)格式，Wasm实现(如解释器)通常会把二进制模块解码为内部形式(即内存格式，比如C/C++/Go结构体)，然后再进行后续处理。
<div align=center>
 <img src="./assets/PL/3.22-1.png"></img>
 <div>wasm三种格式之间关系</div>
</div>

从语义上讲，wasm模块从二进制格式到最终被执行可分为3个阶段：解码、验证、执行。解码阶段将二进制模块解码为内存格式；验证阶段对模块进行静态分析，确保模块的结构满足规范要求；执行阶段分为实例化和函数调用两个阶段。
<div align=center>
 <img src="./assets/PL/3.22-2.png"></img>
 <div>wasm模块语义执行阶段</div>
</div>

## 1.2 wasm 二进制格式
wasm规范一共定义了12种段，每种段都有一个ID，0-11，除了自定义段，其他段都只能最多出现一次，且出现顺序严格按照ID顺序(是因为很多段与段之间有依赖关系，只有知道前者的信息，后者才能解析，wasm二进制格式设计原则之一就是(One-Pass)一遍完成模块解析、验证和编译，即**可流式处理**)。
<div align=center>
 <img src="./assets/PL/3.22-3.png" width="60%"></img>
 <div>
    <img src="./assets/PL/3.23-1.png" width="60%"></img>
 </div>
 <div>wasm二进制格式总体结构</div>
</div>

**类型段(Type Section) ID : 1**
存储wasm模块用到的所有的类型，大部分是函数类型(函数签名)。
**导入段和导出段(Import and Export Section) ID : 2/7**
存储wasm模块中所有的导入和导出项，多个模块可以通过导入导出项链接在一起。
**函数段和代码段(Function and Code Section) ID : 3/10**
内部函数信息被分开存储在这两个段中，函数段是一个索引表，列出内部函数对应的签名索引；代码段存储内部函数的局部变量信息和字节码。
**表段和元素段(Table and Element Section) ID : 4/9**
表段列出模块内定义的所有表，元素段列出表初始化数据。wasm规范规定模块最多只能导入或定义一张表，表内容和间接函数调用有关。
**内存段和数据段(Memory and Data Section) ID : 5/11**
内存段列出模块内定义的所有内存，数据段列出内存初始化数据。wasm规范规定模块最多只能导入或定义一块内存。
**全局段(Global Section) ID : 6**
该段列出模块内定义的所有全局变量信息，包括值类型、可变性(Mutability)和初始值。
**起始段(Start Section) ID : 8**
该段给出模块的起始函数索引，起始函数主要两个作用，一个是模块加载后进行一些初始化工作，另一个是把模块变成可执行程序。
**自定义段(Custom Section) ID : 0**
该段给编译器等工具使用，可以存放函数名等调试信息，或者其他附加信息。自定义段与wasm语义无关，完全忽略也不会影响执行。

**wasm二进制编码格式**
为了让wasm二进制格式尽可能紧凑，段的字节数、各种索引等整数值都是按照**LEB128**格式编码后存储的。
**LEB128**是一种变长编码格式(variable-length code)。i32编码后可能为1-5byte，i64编码后可能1-10byte。越小的整数，编码后占用字节数就越少。
- 采用小端编码，低位字节在前
- 采用128进制，每7bit为一组，由一字节的第七位承载，空出来的最高位是标志位，1表示还有后续字节，0表示没有。
- LEB128无符号整数编码小于128的整数编码后是他本身，因为只有一字节，首位就为0
- LEB128有两种变体，分别用来编码无符号整数和有符号整数
**LEB128解码** 
<div align=center>
<div>
 <img src="./assets/PL/3.24-1.png" ></img>
</div>
 <div>LEB128无符号整数解码</div>
<div>
 <img src="./assets/PL/3.24-2.png" ></img>
</div>
 <div>LEB128有符号整数解码</div>
</div>
判断字节个数、反转字节顺序、去掉最高位字节，只有最后一个字节的处理方式不同，最后一字节的第二高位是符号位，1表示负数，需要最高位全部补1，0为正数，最高位全补0。
放眼整个wasm二进制格式，建立基本类型对照。
<div align=center>
 <img src="./assets/PL/3.24-3.png" ></img>
 <div>wasm基本类型映射表</div>
</div>

### 1.2.1 类型段

- Wasm 二进制的每个段都以 1 字节的段 ID 开始
- 段的统一编码格式如下
  ```
  sec: id|byte_count|byte+   # byte_count 有助于跳过某些段
  byte_count: u32            # LEB128 编码的 32 位无符号整数
  ```
- 大部分段可以包含多个项目，以**向量**结构编码，用 `vec<T>` 表示，具体编码方式为：先记录项目数量，然后再依次记录每个项目，**如果项目数为00，则后面项目也不需记录占字节了**。
- 借助向量表示法，段编码格式可简写为 `id|vec<byte>`，**后续部分会多次沿用这种简写格式**。
- 类型段的编码格式
  ```
  type_count: u32            # LEB128 编码的 32 位无符号整数
  type_sec:  0x01|byte_count|vec<func_type>
  vec<func_type>:  type_count|func_type+
  func_type: 0x60|vec<val_type>|vec<val_type> # 第一个 vec 表示参数列表，第二个 vec 表示结果列表
  ```
### 1.2.2 导入段
- 模块可以导出 4 种类型成员：函数、表、内存和全局变量，也可以从其他模块导入这 4 种成员
- 借助导入和导出串联多个模块，完成复杂功能
- 导入段的每项需要给出以下信息
  - 模块名
  - 成员名
  - 具体描述信息
- 导入段的编码格式如下
  ```
  import_sec: 0x02|byte_count|vec<import>
  # module_name 和 member_name 可以是任意 UTF-8 编码的字符串，以 vec<byte> 形式存储
  import:     module_name|member_name|import_desc
  module_name,member_name : length_int | byte+
  # tag={0 ： "函数", 1 : "表", 2 : "内存", 3 : "全局变量"}，作为区分导入的四种类型成员，下面方括号表示只出现其中一个元素
  import_desc: tag|[type_idx, table_type, mem_type, global_type]
  type_idx : u32
  ```

### 1.2.3 函数段
- 编码格式
  ```
  func_sec: 0x03|byte_count|vec<type_idx>
  ```


 ### 1.2.4 表段
- Wasm 规范目前规定模块最多只能定义一张表，且元素类型必须为函数引用（编码为 0x70）
- 除了元素类型，表还需要指定元素数量的限制，包括**必须的下限**和**可选的上限**
- 编码格式如下
  ```
   table_sec: 0x04|byte_count|vec<table_type> # 目前 vec 长度必须为 1
  table_type: 0x70|limits
  # tag为0，则指定下限 tag为1，则上下限都要指定
      limits: tag|min|max?
  ```

### 1.2.4 内存段 
- Wasm 规范规定模块最多只能定义一块内存
- 内存只需指定内存页数限制
- 编码格式如下
  ```
   mem_sec: 0x50|byte_count|vec<mem_type> # 目前 vec 长度只能是 1
  mem_type: limits
    limits: tag|min|max?
  ```

### 1.2.5 全局段 
- 全局段列出模块内定义的所有全局变量，全局项需要指定全局变量的类型（包括值类型和可变性）以及初始值
- 编码格式如下
  ```
   global_sec: 0x06|byte_count|vec<global>
       global: global_type|init_expr
          mut: u32 # (1 可变，0 不可变)
  global_type: val_type|mut
         expr: byte*|0x0B
  ```

### 1.2.6 导出段 
- 导出段列举模块的所有导出成员，只有被导出的成员才能被外界访问
- 编码格式如下
  ```
   export_sec: 0x07|byte_count|vec<export>
       export: name|export_desc
  export_desc: tag|[func_idx, table_idx, mem_idx, global_idx]
  ```

### 1.2.7 起始段 
- 编码格式如下
  ```
  start_sec: 0x08|byte_count|func_idx
  ```

### 1.2.8 元素段 
- 每个元素项包含3部分信息：表索引（初始化哪张表）、表内偏移量（从哪里开始初 始化）、函数索引列表（给定的初始数据）
- 编码格式如下
  ```
  elem_sec: 0x09|byte_count|vec<elem>
      elem: table_idx|offset_expr|vec<func_idx> # 目前 table_idx 只能为 0
  ```

### 1.2.9 代码段
- 存放函数的字节码和方法的局部变量
- 为了节约空间，局部变量信息是压缩后存储的：连续多个相同类型的局部变量会被分为一组，统一记录变量数量和类型
- 注意：每个代码项都以该项所占字节数开头，以便于 Wasm 实现并行处理（例如，验证、分析和编译等）函数字节码
- 编码格式如下
  ```
  code_sec: 0x0A|byte_count|vec<code>
      code: byte_count|vec<locals>|expr
    locals: local_count|val_type
  ```

### 1.2.10 数据段
- 数据段 vs 元素段
  - 元素段存放表初始化数据，数据段存放内存初始化数据
  - 数据项包含三部分信息：内存索引、内存偏移量、初始数据
  - 目前模块最多只能导入或定义一块内存，所以内存索引必须为 0
  - 内存偏移量也由表达式指定
- 编码格式
  ```
  data_sec: 0x0B|byte_count|vec<data>
      data: mem_idx|offset_expr|vec<byte>
  ```

### 1.2.11 自定义段
- 相对于其他段，自定义段有两点不同
  - 不参与模块语义
  - 可以出现在任意非自定义段前后，且次数不限
- Wasm 规范要求自定义段必须以一个字符串开头，标识自定义段
- Wasm 规范在附录 7.4 定义了一个标准的自定义段，名为 `name`，专门用于存放模块名、内部函数名和局部变量名
- 编码格式如下
  ```
  custom_sec: 0x00|byte_count|name|namedata
  namedata: modulenamesubsec?|funcnamesubsec?|localnamesubsec?
  modulenamesubsec: 0x00|byte_count|modulename
  funcnamesubsec: 0x01|byte_count|namemap
  namemap: vec<nameassoc>
  nameassoc: idx|name
  localnamesubsec: 0x02|byte_count|indirectnamemap
  indirectnamemap: vec<indirectnameassoc>
  indirectnameassoc: idx|namemap
  ```

## 1.3 wasm指令集格式
wasm二进制模块中的代码(代码段中的函数代码，全局段中的初始值表达式，元素和数据段中的偏移量表达式)也是由一条一条指令构成。

wasm指令包括两部分信息：
- 操作码(opcode) : 指令的ID，决定指令将执行的操作
- 操作数(operands) : 指令的参数，决定指令执行的结果
  
### 1.3.1 操作码 
wasm指令的操作码固定为一个字节， 因此指令最多有256种。wasm共178条指令，大致分为五类：
- 控制指令，13条
- 参数指令，2条
- 变量指令，5条
- 内存指令，25条
- 数值指令，133条
  - 常量指令
  - 测试指令
  - 比较指令
  - 算术运算指令
  - 类型转换指令

<div align=center>
 <img src="./assets/PL/3.25-1.png" ></img>
 <div>wasm指令集操作码分布图</div>
</div>

**助记符**
- 为了方便开发者书写和理解，wasm 规范为每个操作码定义了助记符（Mnemonic）
- 两条命名规则
  - 类型前缀：数值指令的前缀通常为 `i32`、`i64`、`f32`、`f64`，例如，`i32.load`
  - 符号后缀
    - 如果整数指令的结果不受符号影响，则操作码助记符无特别后缀，例如，`i32.add`
    - 否则指令决定将整数解释为有符号（操作码助记符以 `_s` 结尾）还是无符号（操作码助记符以 `_u` 结尾），两者一般成对出现，例如 `i64.div_s`<->`i64.div_u`

**立即数**
- 为了方便开发者书写和理解，wasm 规范为每个操作码定义了助记符（Mnemonic）
- 两条命名规则
  - 类型前缀：数值指令的前缀通常为 `i32`、`i64`、`f32`、`f64`，例如，`i32.load`
  - 符号后缀
    - 如果整数指令的结果不受符号影响，则操作码助记符无特别后缀，例如，`i32.add`
    - 否则指令决定将整数解释为有符号（操作码助记符以 `_s` 结尾）还是无符号（操作码助记符以 `_u` 结尾），两者一般成对出现，例如 `i64.div_s`<->`i64.div_u`

### 1.3.2 立即数

- 操作数分为两种
  - **静态操作数**
    - 直接编码在指令里，跟在操作码后面
    - 又称为指令的**静态立即参数**（Static Immediate Arguments），简称**立即数**
  - **动态操作数**：在运行时从操作数栈获取。后续部分如无特别说明，操作数特指动态操作数
- 立即数大致分为
  - 数值（包括常量和索引）
  - 内存指令参数
  - 控制指令参数
- 内存指令：内存加载/存储系列指令需要指定内存偏移量和对齐提示
- `block` 和 `loop` 指令
  - wasm 使用 `block`、`loop` 和 `if` 这三种指令定义顺序、循环和分支结构的起点，均以 `end` 指令为终点，形成内部是嵌套的指令序列
  - `br` 系列指令可跳出 `block` 和 `if` 块，或者重新开始 `loop` 块
  - **多返回值提案接受前**，块最多只有一个结果，其类型用一个字节表示（0x7F->`i32`，0x7E->`i64`，0x7D->`f32`，0x7C->`f64`，`0x40`->`void`）
  - **多返回值提案接受后**，块类型被重新解释为 LEB128 有符号整数
    - 负数：-1、-2、-3、-4 和 -64 分别对应限制放开前的 5 种结果
    - 非负数：必须是有效的类型索引（**块类型也存在类型段**）
- `if` 指令类似 `block` 指令，只是需要额外考虑 `else` 分支
- `br_table` 指令
  - `br` 系列指令包括 4 条：`br`、`br_if`、`br_table` 和 `return`
  - `return` 没有立即数
  - `br` 和 `br_if` 指令的立即数是索引类型
  - `br_table` 的立即数包括一个跳转表和默认跳转标签，类似 Go 语言的 `switch`

### 1.3.3 操作数
- wasm 规范实际上定义了一台概念上的**栈式虚拟机**。绝大多数的 wasm 指令都是基于这个栈式虚拟机工作：从栈顶弹出若干个数，进行计算，然后把结果压栈
- 运行时位于栈顶并被指令操纵的数叫做指令的**动态操作数**，简称**操作数**。相应地，这个栈称为**操作数栈**。为了实现控制指令，wasm还需要一个控制栈。
- 由于采用了栈式虚拟机，大部分 wasm 指令（特别是数值指令）都很短，只有一个操作码，因为操作数都已隐含在栈上。

> Python 和 Ruby 等语言也用栈式虚拟机。Lua 和 Android 早期的 Dalvik 虚拟机采用的是寄存器虚拟机，其指令需要包含寄存器索引，所以寄存器虚拟机的指令一般较长。

## 1.4 wasm指令分析

### 1.4.1 数值指令
- 4 条常量指令和8条饱和截断指令
  - `i32.const`/`i64.const` 带 `s32`/`s64` 类型的立即数，使用 LEB128 有符号编码
  - `f32.const`/`f64.const` 带 `f32`/`f64` 类型的立即数，固定占用 4/8 字节
  - `trunc_sat`（操作码 0xFC）：格式为`前缀操作码（0xFC）+ 子操作码`，带一个单字节的子操作码作为立即数
  
- 编码格式
  ```
  i32.const: 0x41|s32
  i64.const: 0x42|s64
  f32.const: 0x43|f32
  f64.const: 0x44|f64
  trunc_sat: 0xfc|byte
  num_instr: opcode
  ```

- 二进制分析
```bash
  wat2wasm 01-numeric.wat 
  wasm-objdump -d 01-numeric.wasm 

  01-numeric.wasm:	file format wasm 0x1

  Code Disassembly:

  000016 func[0]:
  000017: 43 cd cc 44 41             | f32.const 0x1.89999ap+3   # 12.3
  00001c: 43 66 66 36 42             | f32.const 0x1.6cccccp+5   # 45.6
  000021: 92                         | f32.add
  000022: fc 00                      | i32.trunc_sat_f32_s
  000024: 1a                         | drop
  000025: 0b                         | end
```

### 1.4.2 变量指令
- 变量指令共 5 条
  - 3 条用于读写局部变量，立即数是局部变量索引，用的是LEB128无符号整数编码
  - 2 条用于读写全局变量，立即数是全局变量索引
- 编码格式
  ```
   local.get:  0x20|local_idx
   local.set:  0x21|local_idx
   local.tee:  0x22|local_idx
  global.get: 0x23|global_idx
  global.set: 0x24|global_idx
  ```

- 二进制分析
```bash
  wat2wasm 02-variable.wat 
  wasm-objdump -d 02-variable.wasm 

  02-variable.wasm:	file format wasm 0x1

  Code Disassembly:

  000025 func[0]:
  000026: 23 00                      | global.get 0    
  000028: 24 01                      | global.set 1
  00002a: 20 00                      | local.get 0
  00002c: 21 01                      | local.set 1
  00002e: 0b                         | end
```

### 1.4.3 内存指令
- 内存指令共 25 条
  - 14 条加载指令，用于将内存数据加载到操作数栈，有两个立即数：对齐提示和内存偏移量
  - 9 条存储指令，用于将操作数栈顶数据写回内存，有两个立即数：对齐提示和内存偏移量
  - 2 条指令用于获取和拓展内存页数，立即数是内存索引。wasm 规范目前规定模块只能导入或定义一块内存，所以内存索引只起到占位作用，必须为 0
- 编码格式

  ```
  load_instr: opcode|align|offset # align: u32, offset: u32
  store_instr: opcode|align|offset
  memory.size: 0x3f|0x00
  memory.grow: 0x40|0x00
  ```
- 具体例子
  ```
    (module
    (memory 1 8)
    (data (offset (i32.const 100)) "hello")

    (func
      (i32.const 1) (i32.const 2)
      (i32.load offset=100)
      (i32.store offset=100)
      (memory.size) (drop)
      (i32.const 4) (memory.grow) (drop)
    )
  )
  ```

- 二进制分析
  ```bash
  wat2wasm 03-memory.wat 
  wasm-objdump -d 03-memory.wasm 

  03-memory.wasm:	file format wasm 0x1

  Code Disassembly:

  00001c func[0]:
  00001d: 41 01                      | i32.const 1
  00001f: 41 02                      | i32.const 2
  000021: 28 02 64                   | i32.load 2 100
  000024: 36 02 64                   | i32.store 2 100
  000027: 3f 00                      | memory.size 0
  000029: 1a                         | drop
  00002a: 41 04                      | i32.const 4
  00002c: 40 00                      | memory.grow 0
  00002e: 1a                         | drop
  00002f: 0b                         | end
  ```

### 1.4.4 结构化控制指令
- 控制指令共 13 条，包括结构化控制指令、跳转指令、函数调用指令等
- 结构化控制指令有 3 条
  - `block`、`loop` 和 `if`
  - 必须和 `end` （操作码 0x0B）指令搭配，成对出现
  - 如果 `if` 指令有两条分支，则中间由 `else` 指令（操作码 0x05）分隔
  - `end` 和 `else` 也称为**伪指令**
- 编码格式

  ```
  block_instr: 0x02|block_type|instr*|0x0b
   loop_instr: 0x03|block_type|instr*|0x0b
     if_instr: 0x04|block_type|instr*|(0x05|instr*)?|0x0b
   block_type: s32
  ```
- 具体例子
  ```
    (module
    (func (result i32)
      (block (result i32)
        (i32.const 1)
        (loop (result i32)
          (if (result i32)
            (i32.const 2)
            (then (i32.const 3))
            (else (i32.const 4))
          )
        )
        (drop)
      )
    )
  )
  ```

- 二进制分析
  ```bash
  wat2wasm 04-block.wat 
  wasm-objdump -d 04-block.wasm 

  04-block.wasm:	file format wasm 0x1

  Code Disassembly:

  000017 func[0]:
  000018: 02 7f                      | block i32
  00001a: 41 01                      |   i32.const 1
  00001c: 03 7f                      |   loop i32
  00001e: 41 02                      |     i32.const 2
  000020: 04 7f                      |     if i32
  000022: 41 03                      |       i32.const 3
  000024: 05                         |     else
  000025: 41 04                      |       i32.const 4
  000027: 0b                         |     end
  000028: 0b                         |   end
  000029: 1a                         |   drop
  00002a: 0b                         | end
  00002b: 0b                         | end
  ```

### 1.4.5 跳转指令
- 共 4 条指令如下

  指令 | 操作码| 作用 | 立即数
  ----|----|----|-------
  `br` | 0x0C | 无条件跳转 | 目标标签索引
  `br_if` | 0x0D | 有条件跳转 | 目标标签索引
  `br_table` | 0x0E | 查表跳转 | 目标标签索引表和默认标签索引
  `return` | 0x0F | 直接跳出最外层循环并导致整个函数返回 | N/A
  目标标签索引表: vec<label>
  默认标签索引: default # u32类型

- 具体例子
  ```
    (module
    (func
      (block
        (block
          (block
            (br 1)
            (br_if 2 (i32.const 100))
            (br_table 0 1 2 3)
            (return)
          )
        )
      )
    )
  )
  ```

- 二进制分析
  ```bash
  wat2wasm 05-break.wat 
  wasm-objdump -d 05-break.wasm 

  05-break.wasm:	file format wasm 0x1

  Code Disassembly:

  000016 func[0]:
  000017: 02 40                      | block
  000019: 02 40                      |   block
  00001b: 02 40                      |     block
  00001d: 0c 01                      |       br 1
  00001f: 41 e4 00                   |       i32.const 100
  000022: 0d 02                      |       br_if 2
  000024: 0e 03 00 01 02 03          |       br_table 0 1 2 3
  00002a: 0f                         |       return
  00002b: 0b                         |     end
  00002c: 0b                         |   end
  00002d: 0b                         | end
  00002e: 0b                         | end
  ```

### 1.4.6 函数调用指令
- 两种函数调用方式
  - `call`（操作码 0x10）进行直接函数调用，函数索引由立即数指定
  - `call_indirect`（操作码 0x11）进行间接函数调用，函数签名的签名由立即数指定，到运行时才能知道具体调用的函数
- 编码格式

  ```
     call_instr: 0x10|func_idx
  call_indirect: 0x11|type_idx|0x00
  ```
- 间接函数调用指令需要查表才能完成，由第 2 个立即数指定查哪张表。目前由于模块最多只能导入或定义一张表，所以这个立即数只起到占位作用，必须为 0
- 二进制分析
  ```bash
  wat2wasm 06-call.wat 
  wasm-objdump -d 06-call.wasm 

  06-call.wasm:	file format wasm 0x1

  Code Disassembly:

  00002b func[0]:
  00002c: 10 00                      | call 0
  00002e: 41 02                      | i32.const 2
  000030: 11 01 00                   | call_indirect 1 0
  000033: 0b                         | end
  ```

### 1.4.6 其他指令
前面章节没有介绍指令和表达式解码逻辑，包括
- 全局项的初始化表达式
- 元素和数据项的偏移量表达式
- 代码项的字节码

其编码格式如下

```
global: global_type|init_expr
  elem: table_idx|offset_expr|vec<func_idx>
  data: mem_idx|offset_expr|vec<byte>
  code: byte_count|vec<locals>|expr
  expr: instr*|0x0b
```

##### 1.1.1.1 wabt观察二进制格式
```bash
// dump wasm模块所有信息
wasm-objdump -x *.wasm

```

# 2. Python 
## 2.1 Python源码剖析
### 2.1.1 对象模型
**一切皆对象**
Python是一门面向对象语言，实现了一个完整的面向对象系统，在Python的对象模型世界，**一切皆对象**，**基本类型也是对象**，python所有基本类型内部均由对象实现。一个整数，一个字符串都是对象。
python中的类型也是一种对象，称为**类型对象**。
```python
>>>int
<class 'int'>
```
通过整数类型实例化可以得到一个整数对象，称为**实例对象**
```python
>>>int('1024')
1024
```
面向对象理论中的“类”和“对象”在python内部都是通过对象实现的，这是python最大的特点。
<div align=center> 
<img src="./assets/PL/4.3-1.jpg" ></img>   
</div>

#### 2.1.1.1 类型、对象体系
##### 2.1.1.1.1 类型体系
**内置类型**
a是一个整数对象(实例对象)，其类型是整数类型(类型对象)：
```python
>>> a = 1
>>> type(a)  # 实例对象
<class 'int'>
>>> isinstance(a, int)  # 实例对象
True
```  
整数类型的类型则是：  
```python
>>> type(int)
<class 'type'>
```
type，即**类型的类型**，这个类型特殊，它的实例对象还是**类型对象**。
还有一个特殊类型`object`，是所有类型的基类：
```python
>>> issubclass(int, object)
True
```  
<div align=center> 
<img src="./assets/PL/4.3-2.jpg" ></img>   
</div>

**自定义类型**
```python
class Dog(object):

  def yelp(self):
    print('woof')
```
dog实例类型为Dog：
```python
>>> dog = Dog()
>>> type(dog)
<class '__main__.Dog'>
```
Dog类的类型自然也是type，其基类是object：
```python
>>> type(Dog)
<class 'type'>
>>> issubclass(Dog, object)
True
```
<div align=center> 
<img src="./assets/PL/4.3-3.jpg" ></img>   
</div>  
给出一Dog类子类Sleuth类，类型系统如下图：
<div align=center> 
<img src="./assets/PL/4.3-4.jpg" ></img>   
</div>
<br>
现在来讨论type和object这两个特殊的类型。
object是所有类型的基类，本质上也是一种类型，所以其类型必然是type。而type是所有类型的类型，其类型还是它自己。

```python
>>> type(object)
<class 'type'>
>>> type(type)
<class 'type'>
```
object是所有类型的基类，理论上也是type的基类(__base__):
```python
>>> type.__base__
<class 'object'>
```
<div align=center> 
<img src="./assets/PL/4.3-5.jpg" ></img>   
</div>
即所有类型的基类收敛于object，所有的类型的类型都是type，包括type它自己。

##### 2.1.1.1.2 变量只是名字
```python
>>> a = 1
>>> id(a)
4302704784
```
定义一个变量a，通过id内建函数取出其“地址”
定义另一个变量b，以a赋值，并取出b的“地址”
```python
>>> b = a
>>> id(b)
4302704784
```
a和b的地址相同，在python中，一切皆对象，整数也是如此，**变量只是一个与对象关联的名字**。python内部，变量只是一个名字，保存着指向实例对象的指针，进而与其绑定。变量赋值只拷贝指针，并不拷贝指针指向的对象。
<div align=center> 
<img src="./assets/PL/4.3-6.jpg" ></img>   
</div>

##### 2.1.1.1.3 可变对象与不可变对象
```python
>>> a = 1
>>> id(a)
4302704784
>>> a += 1
>>> id(a)
4302704816
```
变量a自增1之后对象直接变了(因为地址变了，变量名指向的不是一个对象了)，原因要从**可变对象**，与**不可变对象**说起。**可变对象**在对象创建后，其值可以进行修改；而**不可变对象**在对象创建后整个生命周期，其值都不可修改。
python中，整数类型是不可变类型，整数对象是不可变对象。修改整数对象时，python将以新数值创建一个新对象，并进行变量名绑定，就对象若无其他引用，将被释放。每次修改整数引发的创建新对象，释放旧对象的效率问题，将由**小整数池**等手段优化。
<div align=center> 
<img src="./assets/PL/4.3-7.jpg" ></img>   
</div>

可变对象典型例子是**列表(list)**:

```python
>>> l = [1, 2]
>>> id(l)
4385900424
>>> l.append(3)
>>> id(l)
4385900424
```
list添加元素后，地址没变。列表对象内部维护了一个**动态数组**，存储元素对象的指针：
<div align=center> 
<img src="./assets/PL/4.3-8.jpg" ></img>   
</div>

##### 2.1.1.1.4 定长对象与变长对象
标准库sys模块提供了一个`getsizeof`函数查看对象大小
```python
>>> import sys
>>> sys.getsizeof(1)
28
>>> sys.getsizeof(100000000000000000)
32
>>> sys.getsizeof(100000000000000000000000000000000000000000000)
44
```
整数对象的大小与其数值有关，像这样**大小不固定**的对象称为**变长对象**
python采用类似C++中**大整数类**的思路实现整数对象————串联多个普通32为整数，以便支持更大数值范围。**整数对象头部额外存储一些信息，记录对象用了多少个32位整数。**
```python
>>> sys.getsizeof('a')
50
>>> sys.getsizeof('abc')
52
```
字符串对象也是变长对象。
定长对象————浮点数对象float：
```python
>>> sys.getsizeof(1.)
24
>>> sys.getsizeof(1000000000000000000000000000000000.)
24
```
浮点数是由一个double实现，就算表示很大的数，浮点数对象大小也不变。64位的double牺牲了精度，来表示大范围。
```python
>>> int(1000000000000000000000000000000000.)
999999999999999945575230987042816
```

| 类别      | 特点 |
| ----------- | ----------- |
| 可变对象      | 对象创建后可以修改       |
| 不可变对象   | 对象创建后不可修改        |
| 定长对象      | 对象大小固定       |
| 变长对象   | 对象大小不固定        |

#### 2.1.1.2 深入探究对象
**PyObject，对象的基石**
在python内部，对象都由`PyObject`结构体表示，对象引用则是指针`PyObject *`。PyObject结构体定义于头文件`object.h`，路径为`Include/object.h`。
```cpp
typedef struct _object {
    _PyObject_HEAD_EXTRA
    Py_ssize_t ob_refcnt;  // 引用计数
    struct _typeobject *ob_type;  // 类型指针
} PyObject;
```
**类型指针**指向对象的类型对象，类型对象**描述实例对象的数据及行为**
_PyObject_HEAD_EXTRA 宏的定义，同样在 Include/object.h 头文件内：
```cpp
#ifdef Py_TRACE_REFS
/* Define pointers to support a doubly-linked list of all live heap objects. */
#define _PyObject_HEAD_EXTRA            \
    struct _object *_ob_next;           \
    struct _object *_ob_prev;

#define _PyObject_EXTRA_INIT 0, 0,

#else
#define _PyObject_HEAD_EXTRA
#define _PyObject_EXTRA_INIT
#endif
```
_PyObject_HEAD_EXTRA宏展开为两个指针，用来实现双向链表，双向链表用于跟踪所有**活跃堆对象**，不深入介绍。

对于**变长对象**，需要在PyObject基础上加入长度信息，即PyVarObject：
```cpp
typedef struct {
    PyObject ob_base;
    Py_ssize_t ob_size; /* Number of items in variable part */
} PyVarObject;
```
<div align=center> 
<img src="./assets/PL/4.3-9.jpg" ></img>   
</div>

**具体对象，视其大小是否固定，需要包含头部PyObject或PyVarObject。**头文件里准备了两个宏，方便其他对象使用：
```cpp
#define PyObject_HEAD          PyObject ob_base;
#define PyObject_VAR_HEAD      PyVarObject ob_base;
```
例如，对于大小固定的**浮点对象**，只需在PyObject头部基础上，用一个double加以实现：
```cpp
typedef struct {
    PyObject_HEAD

    double ob_fval;
} PyFloatObject;
```
对于大小不固定的**列表对象**，需在PyVarObject头部基础上，加一个动态数组实现，数组存储列表包含的对象，即PyObject指针：
```cpp
typedef struct {
    PyObject_VAR_HEAD  // PyVarObject中ob_size指示列表当前长度

    PyObject **ob_item;
    Py_ssize_t allocated;
} PyListObject;
```
<div align=center> 
<img src="./assets/PL/4.3-10.jpg" ></img>   
</div> 
**两个初始化对象头部的宏定义**

```cpp
#define PyObject_HEAD_INIT(type)        \
    { _PyObject_EXTRA_INIT              \
    1, type },    // 定长

#define PyVarObject_HEAD_INIT(type, size)       \
    { PyObject_HEAD_INIT(type) size },    //变长
```

**PyTypeObject，类型的基石**
描述对象支持的操作和对象所需内存空间的**元信息**，由一个独立实体保存，与对象**所属类型**密切相关。
PyObject中的ob_type指针，指向一个类型对象，元信息存在其中。PyTypeObject也在 Include/object.h 中定义。
```cpp
typedef struct _typeobject {
    PyObject_VAR_HEAD  // PyTypeObject也是个变长对象，其也含变长对象头部
    const char *tp_name; /* For printing, in format "<module>.<name>" */
    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */

    /* Methods to implement standard operations */
    destructor tp_dealloc;
    printfunc tp_print;

    getattrfunc tp_getattr;
    setattrfunc tp_setattr;

    // ...
    /* Attribute descriptor and subclassing stuff */
    struct _typeobject *tp_base;

    // ......
} PyTypeObject;
```
PyTypeObject是一个变长对象，包括变长对象头部。专有字段有：
- 类型名称 ，即 tp_name 字段；
- 类型的继承信息，例如 tp_base 字段指向基类对象；
- 创建实例对象时所需的 内存信息 ，即 tp_basicsize 和 tp_itemsize 字段；
- 该类型支持的相关 操作信息 ，即 tp_print 、 tp_getattr 等函数指针；

PyTypeObject就是**类型对象**在Python中的表现形式，对应**类**的概念。
```python
>>> float
<class 'float'>
>>> pi = 3.14
>>> e = 2.71
```
对于`pi = 3.14`代码中各个对象在内存中形式如下图：
<div align=center> 
<img src="./assets/PL/4.3-11.jpg" ></img>   
</div>  
由于浮点**类型对象**全局唯一，在 C 语言层面作为一个全局变量静态定义即可，Python 的确就这么做。 浮点类型对象就藏身于 Object/floatobject.c 中， PyFloat_Type 是也：

```cpp
PyTypeObject PyFloat_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)  // ob_type指向PyType_Type，也是个静态全局变量，类型的类型即type的对象
    "float",
    sizeof(PyFloatObject),
    0,
    (destructor)float_dealloc,                  /* tp_dealloc */

    // ...
    (reprfunc)float_repr,                       /* tp_repr */

    // ...
};
```

**PyType_Type，类型的类型**
PyType_Type 在 Object/typeobject.c 中定义：
```cpp
PyTypeObject PyType_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "type",                                     /* tp_name */
    sizeof(PyHeapTypeObject),                   /* tp_basicsize */
    sizeof(PyMemberDef),                        /* tp_itemsize */
    (destructor)type_dealloc,                   /* tp_dealloc */

    // ...
    (reprfunc)type_repr,                        /* tp_repr */

    // ...
};
```

内建类型和自定义类对应的PyTypeObject对象都是通过PyType_Type创建的。type作为**元类型**，可以被用来实现很多高级操作。
<div align=center> 
<img src="./assets/PL/4.3-12.jpg" ></img>   
</div>  

**PyBaseObject_Type，类型之基**
Object/object.c中：
```cpp
if (PyType_Ready(&PyFloat_Type) < 0)
    Py_FatalError("Can't initialize float type");
```
PyType_Ready会对创建好的PyFloat_Type静态定义后进行进一步加工，将tp_base字段初始化成PyBaseObject_Type：
```cpp
int
PyType_Ready(PyTypeObject *type)
{
    // ...

    base = type->tp_base;
    if (base == NULL && type != &PyBaseObject_Type) {
        base = type->tp_base = &PyBaseObject_Type;
        Py_INCREF(base);
    }

    // ...
}
```
PyBaseObject_Type内容：
```cpp
PyTypeObject PyBaseObject_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "object",                                   /* tp_name */
    sizeof(PyObject),                           /* tp_basicsize */
    0,                                          /* tp_itemsize */
    object_dealloc,                             /* tp_dealloc */

    // ...
    object_repr,                                /* tp_repr */
};
```
**完整的对象图**
<div align=center> 
<img src="./assets/PL/4.3-13.jpg" ></img>   
</div> 

#### 2.1.1.3 对象的生命周期
**C API**
Python提供了两种类型C API，让用户可以从C环境中与其交互。Python内部也大量使用这些API。分为**泛型API**和**特型API**。
**泛型API**
泛型API与类型无关，属于**抽象对象层**(Abstract Object Layer AOL)。这类API参数为`PyObject *`,可处理任意类型的对象，API内部根据对象类型区别处理。
```cpp
int
PyObject_Print(PyObject *op, FILE *fp, int flags)
```
以此对象打印函数为例，第一个参数为待打印对象，可以为任意类型对象，因此参数为`PyObject *`,Python内部一般都是通过`PyObject *`引用对象，以达到泛型化的目的。
```cpp
// 打印浮点对象
PyObject *fo = PyFloatObject_FromDouble(3.14);
PyObject_Print(fo, stdout, 0);

// 打印整数对象
PyObject *lo = PyFloatObject_FromLong(100);
PyObject_Print(lo, stdout, 0);
```

**特型API**
**特型API**与类型相关，属于**具体对象层(Concrete Object Layer COL)**。这类API只能作用于某种类型的对象，如浮点对象PyFloatObject。python内部为每一种内置对象提供了这样一组API，如下：
```cpp
PyObject *
PyFloat_FromDouble(double fval)  // 创建一个浮点对象，并初始化为定值fval
```

##### 2.1.1.3.1 对象的创建
前面提到的**元数据**里，包括**对象如何创建**的信息。
python对**内建对象**是非常清晰的，可以直接通过C API来创建对象，像上面的`PyFloat_FromDouble`一样。
对于自定义类型(Dog)，只能通过Dog所对应的类型对象创建实例对象，分配多少内存，如何初始化，都存在类型对象里。
即：
- 通过 C API ，例如 PyFloat_FromDouble ，多用于内建类型；
- 通过类型对象，例如 Dog ，多用于自定义类型，也可用于内建类型；
  - 所以第二种更通用

```python
>>> pi = float('3.14')
```
float类型对象可以被调用，实例化了个浮点数pi，可以被调用的对象就是**可调用对象**。
由于类型对象保存着实例对象的元信息，float类型对象的类型为type，在`PyType_Type` 中，有个`tp_call`函数指针字段。
```cpp
PyTypeObject PyType_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "type",                                     /* tp_name */
    sizeof(PyHeapTypeObject),                   /* tp_basicsize */
    sizeof(PyMemberDef),                        /* tp_itemsize */

    // ...
    (ternaryfunc)type_call,                     /* tp_call */

    // ...
};
```
`float('3.14')`在C层面等价于：
```cpp
PyFloat_Type.ob_type.tp_call(&PyFloat_Type, args, kwargs)
// 即
PyType_Type.tp_call(&PyFloat_Type, args, kwargs)
```
`tp_call`函数在Include/typeobject.c中：
```cpp
static PyObject *
type_call(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    PyObject *obj;

    // ...
    obj = type->tp_new(type, args, kwds);   // 调用类型对象tp_new函数指针申请内存
    obj = _Py_CheckFunctionResult((PyObject*)type, obj, NULL);
    if (obj == NULL)
        return NULL;

    // ...
    type = Py_TYPE(obj);
    if (type->tp_init != NULL) {
        int res = type->tp_init(obj, args, kwds);  // 必要时调用类型对象 tp_init 函数指针对对象进行初始化
        if (res < 0) {
            assert(PyErr_Occurred());
            Py_DECREF(obj);
            obj = NULL;
        }
        else {
            assert(!PyErr_Occurred());
        }
    }
    return obj;
}
``` 
**创建过程图**
<div align=center> 
<img src="./assets/PL/4.3-14.jpg" ></img>   
</div> 

- 调用 float ， Python 最终执行其类型对象 type 的 tp_call 函数；
- tp_call 函数调用 float 的 tp_new 函数为实例对象分配 内存空间 ；
- tp_call 函数必要时进一步调用 tp_init 函数对实例对象进行 初始化 ；

##### 2.1.1.3.2 对象的多态性
python创建一个对象，比如PyFloatObject，此后python内部会通过一个`PyObject *`变量来保存和维护这个对象，而不是通过`PyFloatObject *`。使用PyObject保存和维护对象，可以实现更抽象的上层逻辑，而不用关心具体对象细节。
比如有个计算对象hash值的接口
```cpp
Py_hash_t
PyObject_Hash(PyObject *v);
```
对象类型不同，hash计算方法也不同。如何解决不同呢？
```cpp
Py_hash_t
PyObject_Hash(PyObject *v)
{
    PyTypeObject *tp = Py_TYPE(v);
    if (tp->tp_hash != NULL)
        return (*tp->tp_hash)(v);
    /* To keep to the general practice that inheriting
    * solely from object in C code should work without
    * an explicit call to PyType_Ready, we implicitly call
    * PyType_Ready here and then check the tp_hash slot again
    */
    if (tp->tp_dict == NULL) {
        if (PyType_Ready(tp) < 0)
            return -1;
        if (tp->tp_hash != NULL)
            return (*tp->tp_hash)(v);
    }
    /* Otherwise, the object can't be hashed */
    return PyObject_HashNotImplemented(v);
}
```
函数先通过 ob_type 指针找到对象的类型 (第 4 行)； 然后通过类型对象的 tp_hash 函数指针，调用对应的哈希值计算函数 (第 6 行)。也就说根据对象类型的不同，调用不同的函数版本，这就是**多态性**。
##### 2.1.1.3.3 对象的行为
`PyTypeObject`结构体还定义了很多函数指针，用于表现多态性。这些都对应着**实例对象**在运行时的行为。
而且不同对象也有一些共性，比如整数对象和浮点对象都支持加减乘除等**数值型操作**。元组对象tuple，列表对象list，都支持**下标操作**等。
根据对象行为，可以对对象进行分类如下：
<div align=center> 
<img src="./assets/PL/4.4-1.jpg" ></img>   
</div> 
python为每个类别都定义了一个**标准操作集**

- PyNumberMethods 结构体定义了 数值型 操作；
- PySequenceMethods 结构体定义了 序列型 操作；
- PyMappingMethods 结构体定义了 关联型 操作；

只要**类型对象**提供相关**操作集**，**实例对象**便具备对应的**行为**。操作集字段如下：
```cpp
typedef struct _typeobject {
    PyObject_VAR_HEAD
    const char *tp_name; /* For printing, in format "<module>.<name>" */
    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */

    // ...
    /* Method suites for standard classes */

    PyNumberMethods *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods *tp_as_mapping;

    // ...
    /* Functions to access object as input/output buffer */
    PyBufferProcs *tp_as_buffer;

    // ...
} PyTypeObject;
```
以`float`为例，PyFloat_Type相关字段初始化如下：
```cpp
static PyNumberMethods float_as_number = {
    float_add,          /* nb_add */   // 都是函数指针
    float_sub,          /* nb_subtract */
    float_mul,          /* nb_multiply */
    float_rem,          /* nb_remainder */
    float_divmod,       /* nb_divmod */
    float_pow,          /* nb_power */
    // ...
};

PyTypeObject PyFloat_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "float",
    sizeof(PyFloatObject),

    // ...
    &float_as_number,                           /* tp_as_number */
    0,                                          /* tp_as_sequence */
    0,                                          /* tp_as_mapping */

    // ...
};
```
只有`tp_as_number`非空，所以float对象只支持数值型操作。

##### 2.1.1.3.4 引用计数
python对象创建后引用计数设为1：
```python
>>> a = 3.14
>>> sys.getrefcount(a)
2
```
对象作为函数参数传递，需要将引用计数加一，避免对象被提前销毁，函数返回时，再将引用计数减一。
```python
>>> del a # 此时a被删除，引用计数变为0
```
涉及引用计数调整的操作：
- 容器操作；
- 变量赋值；
- 函数参数传递；
- 属性操作；

当一个对象引用计数为0，python便调用对象对应的析构函数销毁对象，但对象内存不一定会回收。为了提高内存分配效率，python会为一些常用对象维护**内存池**，对象回收后进入内存池，以便下次使用，由此**避免频繁申请、释放内存**。

### 2.1.2 内建对象
#### 2.1.2.1 解剖float对象
float作为python中最简单的对象之一，拥有对象的全部必要水平，值得探究一番。
**内部结构**
float 实例对象在 Include/floatobject.h 中定义：
```cpp
typedef struct {
    PyObject_HEAD
    double ob_fval;
} PyFloatObject;
```
float类型对象全局唯一，作为全局变量定义：
```cpp
PyTypeObject PyFloat_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "float",                                    /* tp_name 保存类型名称float */
    sizeof(PyFloatObject),
    0,
    (destructor)float_dealloc,                  /* tp_dealloc */
    0,                                          /* tp_print */
    0,                                          /* tp_getattr */
    0,                                          /* tp_setattr */
    0,                                          /* tp_reserved */
    (reprfunc)float_repr,                       /* tp_repr */
    &float_as_number,                           /* tp_as_number */
    0,                                          /* tp_as_sequence */
    0,                                          /* tp_as_mapping */
    (hashfunc)float_hash,                       /* tp_hash */
    0,                                          /* tp_call */
    (reprfunc)float_repr,                       /* tp_str */
    PyObject_GenericGetAttr,                    /* tp_getattro */
    0,                                          /* tp_setattro */
    0,                                          /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,   /* tp_flags */
    float_new__doc__,                           /* tp_doc */
    0,                                          /* tp_traverse */
    0,                                          /* tp_clear */
    float_richcompare,                          /* tp_richcompare */
    0,                                          /* tp_weaklistoffset */
    0,                                          /* tp_iter */
    0,                                          /* tp_iternext */
    float_methods,                              /* tp_methods */
    0,                                          /* tp_members */
    float_getset,                               /* tp_getset */
    0,                                          /* tp_base */
    0,                                          /* tp_dict */
    0,                                          /* tp_descr_get */
    0,                                          /* tp_descr_set */
    0,                                          /* tp_dictoffset */
    0,                                          /* tp_init */
    0,                                          /* tp_alloc */
    float_new,                                  /* tp_new */
};
```
- tp_dealloc、tp_init、tp_alloc、tp_new字段是对象创建销毁相关函数
- tp_repr字段是生成语法字符串表示形式的函数
- tp_str字段是生成普通字符串表示形式的函数
- tp_as_number字段是数值操作集
- tp_hash哈希值生成函数

PyFloat_Type中tp_init函数指针为空，是因为float是一种很简单的对象，初始化在tp_new中完成即可。
python为内置对象实现了对象创建API，简化对象创建：
```cpp
// 浮点值创建float
PyObject *
PyFloat_FromDouble(double fval);
// 字符串创建float
PyObject *
PyFloat_FromString(PyObject *v);
```
PyFloat_FromDouble中特化的对象创建流程如下：
```cpp
PyObject *
PyFloat_FromDouble(double fval)
{
    // 为对象分配内存空间，优先使用空闲对象缓存池
    PyFloatObject *op = free_list;
    if (op != NULL) {
        free_list = (PyFloatObject *) Py_TYPE(op);
        numfree--;
    } else {
        op = (PyFloatObject*) PyObject_MALLOC(sizeof(PyFloatObject));
        if (!op)
            return PyErr_NoMemory();
    }
    /* Inline PyObject_New */
    // 为PyFloatObject初始化对象类型字段ob_type以及引用计数ob_refcnt
    // 宏 PyObject_INIT 在头文件 Include/objimpl.h
    (void)PyObject_INIT(op, &PyFloat_Type);
    // 为ob_fval 初始化指定浮点值
    op->ob_fval = fval;
    return (PyObject *) op;
}
// 宏 PyObject_INIT 在头文件 Include/objimpl.h
#define PyObject_INIT(op, typeobj) \
    ( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )
// 宏 _Py_NewReference 将对象引用计数初始化为 1，在 Include/Object.h 中定义
#define _Py_NewReference(op) (                          \
    _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA         \
    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA               \
    Py_REFCNT(op) = 1)
```

**对象的销毁**
python通过Py_DECREF或者Py_XDCREF宏减少引用计数；为0时，用_Py_Dealloc宏回收对象。
```cpp
#define _Py_Dealloc(op) (                               \
    _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \
    (*Py_TYPE(op)->tp_dealloc)((PyObject *)(op)))
// 实际调用float_dealloc
static void
float_dealloc(PyFloatObject *op)
{
    if (PyFloat_CheckExact(op)) {
        if (numfree >= PyFloat_MAXFREELIST)  {
            PyObject_FREE(op);
            return;
        }
        numfree++;
        Py_TYPE(op) = (struct _typeobject *)free_list;
        free_list = op;
    }
    else
        Py_TYPE(op)->tp_free((PyObject *)op);
}
```
对象从创建到销毁所涉及的函数调用关系如下：
<div align=center> 
<img src="./assets/PL/4.4-2.jpg" ></img>   
</div>

**空闲对象缓存池**
浮点运算背后有**大量临时对象创建及销毁**，如计算圆面积：
```python
>>> area = pi * r ** 2
```
首先计算r的平方，中间结果由一个临时对象来保存，假设是t；然后pi与t乘积得到结果赋值给area。最后临时对象t销毁。
如此大量内存分配回收操作，python是这样解决的：**浮点对象销毁后并不着急回收内存，而是将对象放入一个空闲链表。后续创建浮点对象时，先到空闲链表中取，省去分配内存的开销。**
浮点对象的空闲链表在Objects/floatobject.c中定义：
```cpp
// 宏限制链表最大长度，避免过多占用内存
#ifndef PyFloat_MAXFREELIST
#define PyFloat_MAXFREELIST    100
#endif
// 维护当前链表长度
static int numfree = 0;
// 指向空闲链表头节点
static PyFloatObject *free_list = NULL;
```
为了简洁，python把ob_type字段当作next指针来用
<div align=center> 
<img src="./assets/PL/4.4-3.jpg" ></img>   
</div>
在**创建浮点对象时**，会先看看空闲链表是否为空，不为空就从里面拿：

```cpp
PyFloatObject *op = free_list;
// 检查空闲链表是否为空
if (op != NULL) {
    // 如果能用，则取出头节点备用
    free_list = (PyFloatObject *) Py_TYPE(op);
    numfree--;
} else {
    op = (PyFloatObject*) PyObject_MALLOC(sizeof(PyFloatObject));
    // ...
}
```
在销毁对象时，python将其缓存在空闲链表中：
```cpp
// 若空闲链表长度超了，则调用PyObject_FREE回收对象内存
if (numfree >= PyFloat_MAXFREELIST)  {
    PyObject_FREE(op);
    return;
}
// 空闲链表可用，则将对象插入链表头部
numfree++;
Py_TYPE(op) = (struct _typeobject *)free_list;
free_list = op;
```

**对象的行为**
PyFloat_Type中定义了很多函数指针，tp_repr 、 tp_str 、 tp_hash 等
**数值操作集**
python将数值操作抽象为数值操作集`PyNumberMethods`.在Include/object.h 中：
```cpp
typedef struct {
    /* Number implementations must check *both*
    arguments for proper type and implement the necessary conversions
    in the slot functions themselves. */

    binaryfunc nb_add;
    binaryfunc nb_subtract;
    binaryfunc nb_multiply;
    binaryfunc nb_remainder;
    binaryfunc nb_divmod;   // binaryfunc二元函数
    ternaryfunc nb_power;   
    unaryfunc nb_negative;  // unaryfunc 一元函数
    // ...

    binaryfunc nb_inplace_add;
    binaryfunc nb_inplace_subtract;
    binaryfunc nb_inplace_multiply;
    binaryfunc nb_inplace_remainder;
    ternaryfunc nb_inplace_power;
    //...
} PyNumberMethods;
```
float类型对象里定义float的数值操作集`float_as_number`:
```cpp
static PyNumberMethods float_as_number = {
    float_add,          /* nb_add */
    float_sub,          /* nb_subtract */
    float_mul,          /* nb_multiply */
    float_rem,          /* nb_remainder */
    float_divmod,       /* nb_divmod */
    float_pow,          /* nb_power */
    (unaryfunc)float_neg, /* nb_negative */
    // ...

    0,                  /* nb_inplace_add */
    0,                  /* nb_inplace_subtract */
    0,                  /* nb_inplace_multiply */
    0,                  /* nb_inplace_remainder */
    0,                  /* nb_inplace_power */
    // ...
};
```
`float_add`同样位于Objects/floatobject.h 中：
```cpp
static PyObject *
float_add(PyObject *v, PyObject *w)
{
    double a,b;
    // 将两个python对象转换成double浮点变量
    CONVERT_TO_DOUBLE(v, a);
    CONVERT_TO_DOUBLE(w, b);
    PyFPE_START_PROTECT("add", return 0)
    // 求和
    a = a + b;
    PyFPE_END_PROTECT(a)
    // 创建python浮点数对象并返回
    return PyFloat_FromDouble(a);
}
```

#### 2.1.2.2 解剖int对象
int对象在`Include/longobject.h`头文件中定义
```cpp
typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */

// Include/longintrepr.h中如下定义
struct _longobject {
    PyObject_VAR_HEAD  // 变长对象头部
    digit ob_digit[1];  // digit数组，虽然长度为一，后续还会扩张，毕竟c语言内存分配灵活性高
};

#if PYLONG_BITS_IN_DIGIT == 30
typedef uint32_t digit;   // 由此可知，int对象通过整数数组实现大整数
// ...
#elif PYLONG_BITS_IN_DIGIT == 15  // 用小类型是为了省内存，默认32位uint32_t
typedef unsigned short digit;   // 是使用uint32_t还是unsigned short编译python解释器时，可通过宏定义指定版本
// ...
#endif
```
**大整数布局**
整数分正、负、零，三种存储方式不同：
- 整数 绝对值 根据实际情况分为若干部分，保存于 ob_digit 数组中；
- ob_digit 数组长度 保存于 ob_size 字段，对于 负整数 的情况，ob_size 为负；
- 整数 零 以 ob_size 等于 0 来表示，ob_digit 数组为空；

<div align=center> 
<img src="./assets/PL/4.4-4.jpg" ></img>   
</div>

对于整数 1073741824 ( 2 的 30 次方)，**由于 Python 只使用 32 整数的后 30 位**，需要另一个整数才能存储，整数数组长度为 2 。绝对值这样计算：2^30*1+2^0*0=10737418242 

对于整数 -4294967297 (负的 2 的 32 次方加 1 )，同样要长度为 2 的 ob_digit 数组，但 ob_size 字段为负。绝对值这样计算：2^30*4+2^0*1=42949672972 

**小整数静态对象池**
整数对象是**不可变对象**，整数运算结果都以**新对象**返回：
为了避免**大量整数创建销毁**影响性能，采用**小整数对象池**：预先将常用的对象创建好，以备后用。
小整数对象池在`Objects/longobject.c`中实现：
```cpp
#ifndef NSMALLPOSINTS
#define NSMALLPOSINTS           257   // 规定对象池正数个数
#endif
#ifndef NSMALLNEGINTS
#define NSMALLNEGINTS           5     // 规定对象池负数个数
#endif
// -5~-1 1~256
static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];   // 保存预先创建好的小整数对象
```
小整数对象池验证如下：
```python
>>> a = 1 + 0
>>> b = 1 * 1
>>> id(a), id(b)
(4408209536, 4408209536)  # 相同

>>> c = 1000 + 0
>>> d = 1000 * 1
>>> id(c), id(d)
(4410298224, 4410298160)  # 不同
```

#### 2.1.2.3 解剖bytes对象
python中字符串对象(str)采用Unicode编码，Unicode可以表示各种字符，无需关心编码问题。然而在遇到**存储**和**网络通讯**时，字符串对象不可避免要**序列化**为字节序列。所以有了**字节序列对象**————bytes。
<div align=center> 
<img src="./assets/PL/4.4-5.jpg" ></img>   
</div>

**bytes对象结构**
bytes对象用于表示由若干字节组成的**字节序列**及相关**操作**。bytes是**变长对象**，内部由C数组实现。
bytes定义在`Include/bytesobject.h`：
```cpp
typedef struct {
    PyObject_VAR_HEAD
    Py_hash_t ob_shash;  // 保存字节序列的hash值，存下来省的老算
    char ob_sval[1];

    /* Invariants:
     *     ob_sval contains space for 'ob_size+1' elements.
     *     ob_sval[ob_size] == 0. 末尾存\0，以便兼容C字符串
     *     ob_shash is the hash of the string or -1 if not computed yet.
     */
} PyBytesObject;
```
<div align=center> 
<img src="./assets/PL/4.5-1.jpg" ></img>   
</div>

<div align=center> 
<img src="./assets/PL/4.5-2.jpg" ></img>   
</div>
 
bytes对象占用内存空间详细如下：

- 变长对象公共头部 24 字节，ob_refcnt 、 ob_type 、 ob_size 每个字段各占用 8 字节；
- 哈希值 ob_shash 占用 8 字节；
- 字节序列本身，假设是 n 字节；
- 额外 1 字节用于存储末尾处的 \0 ；
即24+8+n+1

**bytes对象行为**
Objects/bytesobject.c 源码文件中找到bytes**类型对象**定义：
```cpp
PyTypeObject PyBytes_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "bytes",
    PyBytesObject_SIZE,
    sizeof(char),
    // ...
    &bytes_as_number,                           /* tp_as_number */
    &bytes_as_sequence,                         /* tp_as_sequence */
    &bytes_as_mapping,                          /* tp_as_mapping */
    (hashfunc)bytes_hash,                       /* tp_hash */
    // ...
};
// 数值行为
static PyNumberMethods bytes_as_number = {
    0,              /*nb_add*/
    0,              /*nb_subtract*/
    0,              /*nb_multiply*/
    bytes_mod,      /*nb_remainder*/  // tp_as_number结构体中只定义了一个操作 % 
}

static PyObject *
bytes_mod(PyObject *self, PyObject *arg)
{
    if (!PyBytes_Check(self)) {
        Py_RETURN_NOTIMPLEMENTED;
    }
    return _PyBytes_FormatEx(PyBytes_AS_STRING(self), PyBytes_GET_SIZE(self),
                             arg, 0);
}
```
bytes对象只是借用`%`运算符实现字符串格式化：
```python
>>> b'msg: a=%d b=%d' % (1, 2)
b'msg: a=1 b=2'
```

**序列型操作**
bytes是序列型对象：
```cpp
static PySequenceMethods bytes_as_sequence = {
    (lenfunc)bytes_length, /*sq_length*/  // 查询序列长度
    (binaryfunc)bytes_concat, /*sq_concat*/  // 合并序列
    (ssizeargfunc)bytes_repeat, /*sq_repeat*/  // 重复序列
    (ssizeargfunc)bytes_item, /*sq_item*/  // 取出给定下标序列元素
    0,                  /*sq_slice*/
    0,                  /*sq_ass_item*/
    0,                  /*sq_ass_slice*/
    (objobjproc)bytes_contains /*sq_contains*/  // 包含关系判断
};
```
**长度**
```cpp
static Py_ssize_t
bytes_length(PyBytesObject *a)
{
    // 查长度直接返回ob_size
    return Py_SIZE(a);
}
```
**合并**
```python
>>> b'abc' + b'cba'
b'abccba'
```
```cpp
static PyObject *
bytes_concat(PyObject *a, PyObject *b)
{
    // 定义缓冲区va、vb
    Py_buffer va, vb;
    // result是结果
    PyObject *result = NULL;

    va.len = -1;
    vb.len = -1;
    // 从待合并对象中获取字节序列所在缓冲区
    if (PyObject_GetBuffer(a, &va, PyBUF_SIMPLE) != 0 ||
        PyObject_GetBuffer(b, &vb, PyBUF_SIMPLE) != 0) {
        PyErr_Format(PyExc_TypeError, "can't concat %.100s to %.100s",
                     Py_TYPE(b)->tp_name, Py_TYPE(a)->tp_name);
        goto done;
    }
    // 如果第一个对象长度为0，则第二个对象为结果
    /* Optimize end cases */
    if (va.len == 0 && PyBytes_CheckExact(b)) {
        result = b;
        Py_INCREF(result);
        goto done;
    }
    // 如果第二个对象长度为0，则第一个对象为结果
    if (vb.len == 0 && PyBytes_CheckExact(a)) {
        result = a;
        Py_INCREF(result);
        goto done;
    }
    // 判断a和b总长度是否超过限制
    if (va.len > PY_SSIZE_T_MAX - vb.len) {
        PyErr_NoMemory();
        goto done;
    }
    // 新建bytes对象给result
    result = PyBytes_FromStringAndSize(NULL, va.len + vb.len);
    // 将字节序列从待合并对象拷贝到结果对象
    if (result != NULL) {
        memcpy(PyBytes_AS_STRING(result), va.buf, va.len);
        memcpy(PyBytes_AS_STRING(result) + va.len, vb.buf, vb.len);
    }
  // 返回结果
  done:
    if (va.len != -1)
        PyBuffer_Release(&va);
    if (vb.len != -1)
        PyBuffer_Release(&vb);
    return result;
}
```
**Py_buffer提供了一套操作对象缓冲区的统一接口**
<br>

**数据拷贝的陷阱**
考虑合并三个bytes对象
```python
# 合并时先合并a和b，得到临时对象t，再将t和c合并得到result
>>> result = a + b + c
```
<div align=center> 
<img src="./assets/PL/4.5-3.jpg" ></img>   
</div>
可以看到a和b的数据需要被拷贝两遍，而且待合并的bytes对象越多，数据拷贝越严重，如下图：
<div align=center> 
<img src="./assets/PL/4.5-4.jpg" ></img>   
</div>
好在bytes对象有个内建方法`join`，可高效合并多个bytes对象：

```python
>>> result = b''.join(segments)
```
join方法对数据拷贝进行优化，先遍历待合并对象，计算总长度；然后根据总长度创建目标对象；最后再遍历待合并对象，逐一拷贝数据。

**字符缓冲池**
为了优化单字节bytes对象的创建效率，python内部维护了一个**字符缓冲池**(像小整数缓冲池一样)，字符缓冲池一开始为空的，随着单字节bytes对象的创建，慢慢进行缓存。
```cpp
static PyBytesObject *characters[UCHAR_MAX + 1];
```
python内部创建字节bytes对象时，先检查目标对象是否已在缓冲池中，`PyBytes_FromStringAndSize`函数是负责创建bytes对象的通用接口，在`Objects/bytesobject.c`中。
```cpp
PyObject *
PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)
{
    PyBytesObject *op;
    if (size < 0) {
        PyErr_SetString(PyExc_SystemError,
            "Negative size passed to PyBytes_FromStringAndSize");
        return NULL;
    }
    // 如果str长度为1，且在字符缓冲池中，则直接返回已缓存的对象
    if (size == 1 && str != NULL &&
        (op = characters[*str & UCHAR_MAX]) != NULL)
    {
#ifdef COUNT_ALLOCS
        one_strings++;
#endif
        Py_INCREF(op);
        return (PyObject *)op;
    }
    // 创建新的bytes对象
    op = (PyBytesObject *)_PyBytes_FromSize(size, 0);
    if (op == NULL)
        return NULL;
    if (str == NULL)
        return (PyObject *) op;
    // 拷贝字节序列
    memcpy(op->ob_sval, str, size);
    /* share short strings */
    // 如果创建的对象为单字节对象，将其放入字符缓冲池
    if (size == 1) {
        characters[*str & UCHAR_MAX] = op;
        Py_INCREF(op);
    }
    return (PyObject *) op;
}
```
**验证**字符缓冲池技术：
```python
# 场景一，单字节对象直接创建缓存并后续引用缓存
>>> a1 = b'a'
>>> a2 = b'a'
>>> a1 is a2
True

# 场景二，非单字节对象
>>> ab1 = b'ab'
>>> ab2 = b'ab'
>>> ab1 is ab2
False
```

#### 2.1.2.4 解剖str对象
python3以后，str对象内部改用Unicode表示，并进行了优化，比如ASCII字符占1字节，中文字符占2字节，并没有都占用4字节。
跟str对象相关的源码如下：
- Include/unicodeobject.h
- Objects/unicodectype.c

在`Include/unicodeobject.h`头文件中，str对象底层底层存储规定如下：
- PyUnicode_1BYTE_KIND ，所有字符码位均在 U+0000 到 U+00FF 之间；
- PyUnicode_2BYTE_KIND ，所有字符码位均在 U+0000 到 U+FFFF 之间，且至少一个大于 U+00FF；
- PyUnicode_4BYTE_KIND ，所有字符码位均在 U+0000 到 U+10FFFF 之间，且至少一个大于 U+FFFF；

```cpp
enum PyUnicode_Kind {
/* String contains only wstr byte characters.  This is only possible
   when the string was created with a legacy API and _PyUnicode_Ready()
   has not been called yet.  */
    PyUnicode_WCHAR_KIND = 0,
/* Return values of the PyUnicode_KIND() macro: */
    PyUnicode_1BYTE_KIND = 1,
    PyUnicode_2BYTE_KIND = 2,
    PyUnicode_4BYTE_KIND = 4
};
// 字符存储单元
typedef uint32_t Py_UCS4;
typedef uint16_t Py_UCS2;
typedef uint8_t Py_UCS1;
```

Unicode内部存储结构因其中文本类型而异，类型kind必须作为Unicode对象公共字段保存。python内部定义了若干个**标志位**，作为Unicode公共字段。
- interned ，是否为 interned 机制维护；
- kind ，类型，用于区分字符底层存储单元大小；
- compact ，内存分配方式，对象与文本缓冲区是否分离；
- ascii ，文本是否均为纯 ASCII ；

Objects/unicodectype.c 源文件中的 PyUnicode_New 函数，根据文本字符数 size 以及最大字符 maxchar 初始化 Unicode 对象。该函数根据 maxchar 为 Unicode 对象选择最紧凑的字符存储单元以及底层结构体：

|                  | maxchar < 128         | maxchar < 256           | maxchar < 65536         | maxchar < MAX_UNICODE   |
| ---------------- | --------------------- | ----------------------- | ----------------------- | ----------------------- |
| kind             | PyUnicode_1 BYTE_KIND | PyUnicode_1 BYTE_KIND   | PyUnicode_2 BYTE_KIND   | PyUnicode_4 BYTE_KIND   |
| ascii            | 1                     | 0                       | 0                       | 0                       |
| 字符存储单元大小 | 1                     | 1                       | 2                       | 4                       |
| 底层结构体  | PyASCIIObject         | PyCompact UnicodeObject | PyCompact UnicodeObject | PyCompact UnicodeObject |

**PyASCIIObject**
```cpp
/* ASCII-only strings created through PyUnicode_New use the PyASCIIObject
   structure. state.ascii and state.compact are set, and the data
   immediately follow the structure. utf8_length and wstr_length can be found
   in the length field; the utf8 pointer is equal to the data pointer. */
typedef struct {
    PyObject_HEAD
    // 文本长度
    Py_ssize_t length;          /* Number of code points in the string */
    Py_hash_t hash;             /* Hash value; -1 if not set */
    // Unicode对象标志位
    struct {
        unsigned int interned:2;
        unsigned int kind:3;
        unsigned int compact:1;
        unsigned int ascii:1;
        unsigned int ready:1;
        unsigned int :24;
    } state;
    // ASCII文本紧接着位于wstr后面
    wchar_t *wstr;              /* wchar_t representation (null-terminated) */
} PyASCIIObject;
```

<div align=center> 
<img src="./assets/PL/4.5-5.jpg" ></img>   
</div>
和bytes文本一样，python也在ASCII文本末尾添加`\0`.因此64位机器上，长度为 n 的纯 ASCII 字符串对象，需要消耗 n+48+1，即 n+49 字节的内存空间。

**PyCompactUnicodeObject**
```cpp
/* Non-ASCII strings allocated through PyUnicode_New use the
   PyCompactUnicodeObject structure. state.compact is set, and the data
   immediately follow the structure. */
typedef struct {
    PyASCIIObject _base;
    // 文本UTF8编码长度
    Py_ssize_t utf8_length;     /* Number of bytes in utf8, excluding the
                                 * terminating \0. */
    // 文本UTF8编码形式，缓存以避免重复编码运算
    char *utf8;                 /* UTF-8 representation (null-terminated) */
    Py_ssize_t wstr_length;     /* Number of code points in wstr, possible
                                 * surrogates count as two code points. */
} PyCompactUnicodeObject;
```

**PyUnicode_1BYTE_KIND**
<div align=center> 
<img src="./assets/PL/4.5-6.jpg" ></img>   
</div>

**PyUnicode_2BYTE_KIND**
<div align=center> 
<img src="./assets/PL/4.5-7.jpg" ></img>   
</div>

**PyUnicode_4BYTE_KIND**
<div align=center> 
<img src="./assets/PL/4.5-8.jpg" ></img>   
</div>

**interned机制**
如果str对象`interned`标识位为1，python虚拟机将为其开启interned机制。
由于 str 是不可变对象，因此 Python 内部将有潜在重复可能的字符串都做成**单例模式**，这就是 interned 机制。Python 具体做法是在内部维护一个全局 dict 对象，所有开启 interned 机制 str 对象均保存在这里；后续需要用到相关对象的地方，则优先到全局 dict 中取，避免重复创建。
验证interned机制：
```python
>>> a = 'abc'
>>> b = 'ab' + 'c'
>>> c = 'abc'
>>> id(a), id(b), a is b
(4424345224, 4424345224, True)
```

#### 2.1.2.5 解剖list对象，容量自适应的数组式容器
list对象可以根据元素个数**自动扩缩容**
**基本用法**
append：尾部追加元素
pop：尾部弹出元素，pop(0)头部弹出元素
insert：向某位置插入元素
index：查找元素第一次出现的位置下标
extend：用一可迭代对象拓展列表，元素逐一追加到尾部
```python
>>> l = [1, 2, 3]
>>> l.extend([1, 2])
>>> l
[1, 2, 3, 1, 2]
```
count：计算元素出现次数
reverse：将列表反转
clear：清空列表
其中对list头部和尾部进行插入弹出操作，时间复杂度分别为O(n)和O(1).
**内部结构**
list对象用PyListObject结构体表示，定义在`Include/listobject.h`中
```cpp
typedef struct {
    PyObject_VAR_HEAD
    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
    PyObject **ob_item;

    /* ob_item contains space for 'allocated' elements.  The number
     * currently in use is ob_size.
     * Invariants:
     *     0 <= ob_size <= allocated
     *     len(list) == ob_size
     *     ob_item == NULL implies ob_size == allocated == 0
     * list.sort() temporarily sets allocated to -1 to detect mutations.
     *
     * Items must normally not be NULL, except during construction when
     * the list is not yet visible outside the function that builds it.
     */
    Py_ssize_t allocated;
} PyListObject;
```