
# 1. WebAssembly 
## 1.1 wasm 概述 
wasm模块有三种格式，前两种是熟知的wasm和wat格式，而第三种为内存(in-memory)格式，Wasm实现(如解释器)通常会把二进制模块解码为内部形式(即内存格式，比如C/C++/Go结构体)，然后再进行后续处理。
<div align=center>
 <img src="./assets/PL/3.22-1.png"></img>
 <div>wasm三种格式之间关系</div>
</div>

从语义上讲，wasm模块从二进制格式到最终被执行可分为3个阶段：解码、验证、执行。解码阶段将二进制模块解码为内存格式；验证阶段对模块进行静态分析，确保模块的结构满足规范要求；执行阶段分为实例化和函数调用两个阶段。
<div align=center>
 <img src="./assets/PL/3.22-2.png"></img>
 <div>wasm模块语义执行阶段</div>
</div>

## 1.2 wasm 二进制格式
wasm规范一共定义了12种段，每种段都有一个ID，0-11，除了自定义段，其他段都只能最多出现一次，且出现顺序严格按照ID顺序(是因为很多段与段之间有依赖关系，只有知道前者的信息，后者才能解析，wasm二进制格式设计原则之一就是(One-Pass)一遍完成模块解析、验证和编译，即**可流式处理**)。
<div align=center>
 <img src="./assets/PL/3.22-3.png" width="60%"></img>
 <div>
    <img src="./assets/PL/3.23-1.png" width="60%"></img>
 </div>
 <div>wasm二进制格式总体结构</div>
</div>

**类型段(Type Section) ID : 1**
存储wasm模块用到的所有的类型，大部分是函数类型(函数签名)。
**导入段和导出段(Import and Export Section) ID : 2/7**
存储wasm模块中所有的导入和导出项，多个模块可以通过导入导出项链接在一起。
**函数段和代码段(Function and Code Section) ID : 3/10**
内部函数信息被分开存储在这两个段中，函数段是一个索引表，列出内部函数对应的签名索引；代码段存储内部函数的局部变量信息和字节码。
**表段和元素段(Table and Element Section) ID : 4/9**
表段列出模块内定义的所有表，元素段列出表初始化数据。wasm规范规定模块最多只能导入或定义一张表，表内容和间接函数调用有关。
**内存段和数据段(Memory and Data Section) ID : 5/11**
内存段列出模块内定义的所有内存，数据段列出内存初始化数据。wasm规范规定模块最多只能导入或定义一块内存。
**全局段(Global Section) ID : 6**
该段列出模块内定义的所有全局变量信息，包括值类型、可变性(Mutability)和初始值。
**起始段(Start Section) ID : 8**
该段给出模块的起始函数索引，起始函数主要两个作用，一个是模块加载后进行一些初始化工作，另一个是把模块变成可执行程序。
**自定义段(Custom Section) ID : 0**
该段给编译器等工具使用，可以存放函数名等调试信息，或者其他附加信息。自定义段与wasm语义无关，完全忽略也不会影响执行。

**wasm二进制编码格式**
为了让wasm二进制格式尽可能紧凑，段的字节数、各种索引等整数值都是按照**LEB128**格式编码后存储的。
**LEB128**是一种变长编码格式(variable-length code)。i32编码后可能为1-5byte，i64编码后可能1-10byte。越小的整数，编码后占用字节数就越少。
- 采用小端编码，低位字节在前
- 采用128进制，每7bit为一组，由一字节的第七位承载，空出来的最高位是标志位，1表示还有后续字节，0表示没有。
- LEB128无符号整数编码小于128的整数编码后是他本身，因为只有一字节，首位就为0
- LEB128有两种变体，分别用来编码无符号整数和有符号整数
**LEB128解码** 
<div align=center>
<div>
 <img src="./assets/PL/3.24-1.png" ></img>
</div>
 <div>LEB128无符号整数解码</div>
<div>
 <img src="./assets/PL/3.24-2.png" ></img>
</div>
 <div>LEB128有符号整数解码</div>
</div>
判断字节个数、反转字节顺序、去掉最高位字节，只有最后一个字节的处理方式不同，最后一字节的第二高位是符号位，1表示负数，需要最高位全部补1，0为正数，最高位全补0。
放眼整个wasm二进制格式，建立基本类型对照。
<div align=center>
 <img src="./assets/PL/3.24-3.png" ></img>
 <div>wasm基本类型映射表</div>
</div>

### 1.2.1 类型段

- Wasm 二进制的每个段都以 1 字节的段 ID 开始
- 段的统一编码格式如下
  ```
  sec: id|byte_count|byte+   # byte_count 有助于跳过某些段
  byte_count: u32            # LEB128 编码的 32 位无符号整数
  ```
- 大部分段可以包含多个项目，以**向量**结构编码，用 `vec<T>` 表示，具体编码方式为：先记录项目数量，然后再依次记录每个项目，**如果项目数为00，则后面项目也不需记录占字节了**。
- 借助向量表示法，段编码格式可简写为 `id|vec<byte>`，**后续部分会多次沿用这种简写格式**。
- 类型段的编码格式
  ```
  type_count: u32            # LEB128 编码的 32 位无符号整数
  type_sec:  0x01|byte_count|vec<func_type>
  vec<func_type>:  type_count|func_type+
  func_type: 0x60|vec<val_type>|vec<val_type> # 第一个 vec 表示参数列表，第二个 vec 表示结果列表
  ```
### 1.2.2 导入段
- 模块可以导出 4 种类型成员：函数、表、内存和全局变量，也可以从其他模块导入这 4 种成员
- 借助导入和导出串联多个模块，完成复杂功能
- 导入段的每项需要给出以下信息
  - 模块名
  - 成员名
  - 具体描述信息
- 导入段的编码格式如下
  ```
  import_sec: 0x02|byte_count|vec<import>
  # module_name 和 member_name 可以是任意 UTF-8 编码的字符串，以 vec<byte> 形式存储
  import:     module_name|member_name|import_desc
  module_name,member_name : length_int | byte+
  # tag={0 ： "函数", 1 : "表", 2 : "内存", 3 : "全局变量"}，作为区分导入的四种类型成员，下面方括号表示只出现其中一个元素
  import_desc: tag|[type_idx, table_type, mem_type, global_type]
  type_idx : u32
  ```

### 1.2.3 函数段
- 编码格式
  ```
  func_sec: 0x03|byte_count|vec<type_idx>
  ```


 ### 1.2.4 表段
- Wasm 规范目前规定模块最多只能定义一张表，且元素类型必须为函数引用（编码为 0x70）
- 除了元素类型，表还需要指定元素数量的限制，包括**必须的下限**和**可选的上限**
- 编码格式如下
  ```
   table_sec: 0x04|byte_count|vec<table_type> # 目前 vec 长度必须为 1
  table_type: 0x70|limits
  # tag为0，则指定下限 tag为1，则上下限都要指定
      limits: tag|min|max?
  ```

### 1.2.4 内存段 
- Wasm 规范规定模块最多只能定义一块内存
- 内存只需指定内存页数限制
- 编码格式如下
  ```
   mem_sec: 0x50|byte_count|vec<mem_type> # 目前 vec 长度只能是 1
  mem_type: limits
    limits: tag|min|max?
  ```

### 1.2.5 全局段 
- 全局段列出模块内定义的所有全局变量，全局项需要指定全局变量的类型（包括值类型和可变性）以及初始值
- 编码格式如下
  ```
   global_sec: 0x06|byte_count|vec<global>
       global: global_type|init_expr
          mut: u32 # (1 可变，0 不可变)
  global_type: val_type|mut
         expr: byte*|0x0B
  ```

### 1.2.6 导出段 
- 导出段列举模块的所有导出成员，只有被导出的成员才能被外界访问
- 编码格式如下
  ```
   export_sec: 0x07|byte_count|vec<export>
       export: name|export_desc
  export_desc: tag|[func_idx, table_idx, mem_idx, global_idx]
  ```

### 1.2.7 起始段 
- 编码格式如下
  ```
  start_sec: 0x08|byte_count|func_idx
  ```

### 1.2.8 元素段 
- 每个元素项包含3部分信息：表索引（初始化哪张表）、表内偏移量（从哪里开始初 始化）、函数索引列表（给定的初始数据）
- 编码格式如下
  ```
  elem_sec: 0x09|byte_count|vec<elem>
      elem: table_idx|offset_expr|vec<func_idx> # 目前 table_idx 只能为 0
  ```

### 1.2.9 代码段
- 存放函数的字节码和方法的局部变量
- 为了节约空间，局部变量信息是压缩后存储的：连续多个相同类型的局部变量会被分为一组，统一记录变量数量和类型
- 注意：每个代码项都以该项所占字节数开头，以便于 Wasm 实现并行处理（例如，验证、分析和编译等）函数字节码
- 编码格式如下
  ```
  code_sec: 0x0A|byte_count|vec<code>
      code: byte_count|vec<locals>|expr
    locals: local_count|val_type
  ```

### 1.2.10 数据段
- 数据段 vs 元素段
  - 元素段存放表初始化数据，数据段存放内存初始化数据
  - 数据项包含三部分信息：内存索引、内存偏移量、初始数据
  - 目前模块最多只能导入或定义一块内存，所以内存索引必须为 0
  - 内存偏移量也由表达式指定
- 编码格式
  ```
  data_sec: 0x0B|byte_count|vec<data>
      data: mem_idx|offset_expr|vec<byte>
  ```

### 1.2.11 自定义段
- 相对于其他段，自定义段有两点不同
  - 不参与模块语义
  - 可以出现在任意非自定义段前后，且次数不限
- Wasm 规范要求自定义段必须以一个字符串开头，标识自定义段
- Wasm 规范在附录 7.4 定义了一个标准的自定义段，名为 `name`，专门用于存放模块名、内部函数名和局部变量名
- 编码格式如下
  ```
  custom_sec: 0x00|byte_count|name|namedata
  namedata: modulenamesubsec?|funcnamesubsec?|localnamesubsec?
  modulenamesubsec: 0x00|byte_count|modulename
  funcnamesubsec: 0x01|byte_count|namemap
  namemap: vec<nameassoc>
  nameassoc: idx|name
  localnamesubsec: 0x02|byte_count|indirectnamemap
  indirectnamemap: vec<indirectnameassoc>
  indirectnameassoc: idx|namemap
  ```

## 1.3 wasm指令集格式
wasm二进制模块中的代码(代码段中的函数代码，全局段中的初始值表达式，元素和数据段中的偏移量表达式)也是由一条一条指令构成。

wasm指令包括两部分信息：
- 操作码(opcode) : 指令的ID，决定指令将执行的操作
- 操作数(operands) : 指令的参数，决定指令执行的结果
  
### 1.3.1 操作码 
wasm指令的操作码固定为一个字节， 因此指令最多有256种。wasm共178条指令，大致分为五类：
- 控制指令，13条
- 参数指令，2条
- 变量指令，5条
- 内存指令，25条
- 数值指令，133条
  - 常量指令
  - 测试指令
  - 比较指令
  - 算术运算指令
  - 类型转换指令

<div align=center>
 <img src="./assets/PL/3.25-1.png" ></img>
 <div>wasm指令集操作码分布图</div>
</div>

**助记符**
- 为了方便开发者书写和理解，wasm 规范为每个操作码定义了助记符（Mnemonic）
- 两条命名规则
  - 类型前缀：数值指令的前缀通常为 `i32`、`i64`、`f32`、`f64`，例如，`i32.load`
  - 符号后缀
    - 如果整数指令的结果不受符号影响，则操作码助记符无特别后缀，例如，`i32.add`
    - 否则指令决定将整数解释为有符号（操作码助记符以 `_s` 结尾）还是无符号（操作码助记符以 `_u` 结尾），两者一般成对出现，例如 `i64.div_s`<->`i64.div_u`

**立即数**
- 为了方便开发者书写和理解，wasm 规范为每个操作码定义了助记符（Mnemonic）
- 两条命名规则
  - 类型前缀：数值指令的前缀通常为 `i32`、`i64`、`f32`、`f64`，例如，`i32.load`
  - 符号后缀
    - 如果整数指令的结果不受符号影响，则操作码助记符无特别后缀，例如，`i32.add`
    - 否则指令决定将整数解释为有符号（操作码助记符以 `_s` 结尾）还是无符号（操作码助记符以 `_u` 结尾），两者一般成对出现，例如 `i64.div_s`<->`i64.div_u`

### 1.3.2 立即数

- 操作数分为两种
  - **静态操作数**
    - 直接编码在指令里，跟在操作码后面
    - 又称为指令的**静态立即参数**（Static Immediate Arguments），简称**立即数**
  - **动态操作数**：在运行时从操作数栈获取。后续部分如无特别说明，操作数特指动态操作数
- 立即数大致分为
  - 数值（包括常量和索引）
  - 内存指令参数
  - 控制指令参数
- 内存指令：内存加载/存储系列指令需要指定内存偏移量和对齐提示
- `block` 和 `loop` 指令
  - wasm 使用 `block`、`loop` 和 `if` 这三种指令定义顺序、循环和分支结构的起点，均以 `end` 指令为终点，形成内部是嵌套的指令序列
  - `br` 系列指令可跳出 `block` 和 `if` 块，或者重新开始 `loop` 块
  - **多返回值提案接受前**，块最多只有一个结果，其类型用一个字节表示（0x7F->`i32`，0x7E->`i64`，0x7D->`f32`，0x7C->`f64`，`0x40`->`void`）
  - **多返回值提案接受后**，块类型被重新解释为 LEB128 有符号整数
    - 负数：-1、-2、-3、-4 和 -64 分别对应限制放开前的 5 种结果
    - 非负数：必须是有效的类型索引（**块类型也存在类型段**）
- `if` 指令类似 `block` 指令，只是需要额外考虑 `else` 分支
- `br_table` 指令
  - `br` 系列指令包括 4 条：`br`、`br_if`、`br_table` 和 `return`
  - `return` 没有立即数
  - `br` 和 `br_if` 指令的立即数是索引类型
  - `br_table` 的立即数包括一个跳转表和默认跳转标签，类似 Go 语言的 `switch`

### 1.3.3 操作数
- wasm 规范实际上定义了一台概念上的**栈式虚拟机**。绝大多数的 wasm 指令都是基于这个栈式虚拟机工作：从栈顶弹出若干个数，进行计算，然后把结果压栈
- 运行时位于栈顶并被指令操纵的数叫做指令的**动态操作数**，简称**操作数**。相应地，这个栈称为**操作数栈**。为了实现控制指令，wasm还需要一个控制栈。
- 由于采用了栈式虚拟机，大部分 wasm 指令（特别是数值指令）都很短，只有一个操作码，因为操作数都已隐含在栈上。

> Python 和 Ruby 等语言也用栈式虚拟机。Lua 和 Android 早期的 Dalvik 虚拟机采用的是寄存器虚拟机，其指令需要包含寄存器索引，所以寄存器虚拟机的指令一般较长。

## 1.4 wasm指令分析

### 1.4.1 数值指令
- 4 条常量指令和8条饱和截断指令
  - `i32.const`/`i64.const` 带 `s32`/`s64` 类型的立即数，使用 LEB128 有符号编码
  - `f32.const`/`f64.const` 带 `f32`/`f64` 类型的立即数，固定占用 4/8 字节
  - `trunc_sat`（操作码 0xFC）：格式为`前缀操作码（0xFC）+ 子操作码`，带一个单字节的子操作码作为立即数
  
- 编码格式
  ```
  i32.const: 0x41|s32
  i64.const: 0x42|s64
  f32.const: 0x43|f32
  f64.const: 0x44|f64
  trunc_sat: 0xfc|byte
  num_instr: opcode
  ```

- 二进制分析
```bash
  wat2wasm 01-numeric.wat 
  wasm-objdump -d 01-numeric.wasm 

  01-numeric.wasm:	file format wasm 0x1

  Code Disassembly:

  000016 func[0]:
  000017: 43 cd cc 44 41             | f32.const 0x1.89999ap+3   # 12.3
  00001c: 43 66 66 36 42             | f32.const 0x1.6cccccp+5   # 45.6
  000021: 92                         | f32.add
  000022: fc 00                      | i32.trunc_sat_f32_s
  000024: 1a                         | drop
  000025: 0b                         | end
```

### 1.4.2 变量指令
- 变量指令共 5 条
  - 3 条用于读写局部变量，立即数是局部变量索引，用的是LEB128无符号整数编码
  - 2 条用于读写全局变量，立即数是全局变量索引
- 编码格式
  ```
   local.get:  0x20|local_idx
   local.set:  0x21|local_idx
   local.tee:  0x22|local_idx
  global.get: 0x23|global_idx
  global.set: 0x24|global_idx
  ```

- 二进制分析
```bash
  wat2wasm 02-variable.wat 
  wasm-objdump -d 02-variable.wasm 

  02-variable.wasm:	file format wasm 0x1

  Code Disassembly:

  000025 func[0]:
  000026: 23 00                      | global.get 0    
  000028: 24 01                      | global.set 1
  00002a: 20 00                      | local.get 0
  00002c: 21 01                      | local.set 1
  00002e: 0b                         | end
```

### 1.4.3 内存指令
- 内存指令共 25 条
  - 14 条加载指令，用于将内存数据加载到操作数栈，有两个立即数：对齐提示和内存偏移量
  - 9 条存储指令，用于将操作数栈顶数据写回内存，有两个立即数：对齐提示和内存偏移量
  - 2 条指令用于获取和拓展内存页数，立即数是内存索引。wasm 规范目前规定模块只能导入或定义一块内存，所以内存索引只起到占位作用，必须为 0
- 编码格式

  ```
  load_instr: opcode|align|offset # align: u32, offset: u32
  store_instr: opcode|align|offset
  memory.size: 0x3f|0x00
  memory.grow: 0x40|0x00
  ```
- 具体例子
  ```
    (module
    (memory 1 8)
    (data (offset (i32.const 100)) "hello")

    (func
      (i32.const 1) (i32.const 2)
      (i32.load offset=100)
      (i32.store offset=100)
      (memory.size) (drop)
      (i32.const 4) (memory.grow) (drop)
    )
  )
  ```

- 二进制分析
  ```bash
  wat2wasm 03-memory.wat 
  wasm-objdump -d 03-memory.wasm 

  03-memory.wasm:	file format wasm 0x1

  Code Disassembly:

  00001c func[0]:
  00001d: 41 01                      | i32.const 1
  00001f: 41 02                      | i32.const 2
  000021: 28 02 64                   | i32.load 2 100
  000024: 36 02 64                   | i32.store 2 100
  000027: 3f 00                      | memory.size 0
  000029: 1a                         | drop
  00002a: 41 04                      | i32.const 4
  00002c: 40 00                      | memory.grow 0
  00002e: 1a                         | drop
  00002f: 0b                         | end
  ```

### 1.4.4 结构化控制指令
- 控制指令共 13 条，包括结构化控制指令、跳转指令、函数调用指令等
- 结构化控制指令有 3 条
  - `block`、`loop` 和 `if`
  - 必须和 `end` （操作码 0x0B）指令搭配，成对出现
  - 如果 `if` 指令有两条分支，则中间由 `else` 指令（操作码 0x05）分隔
  - `end` 和 `else` 也称为**伪指令**
- 编码格式

  ```
  block_instr: 0x02|block_type|instr*|0x0b
   loop_instr: 0x03|block_type|instr*|0x0b
     if_instr: 0x04|block_type|instr*|(0x05|instr*)?|0x0b
   block_type: s32
  ```
- 具体例子
  ```
    (module
    (func (result i32)
      (block (result i32)
        (i32.const 1)
        (loop (result i32)
          (if (result i32)
            (i32.const 2)
            (then (i32.const 3))
            (else (i32.const 4))
          )
        )
        (drop)
      )
    )
  )
  ```

- 二进制分析
  ```bash
  wat2wasm 04-block.wat 
  wasm-objdump -d 04-block.wasm 

  04-block.wasm:	file format wasm 0x1

  Code Disassembly:

  000017 func[0]:
  000018: 02 7f                      | block i32
  00001a: 41 01                      |   i32.const 1
  00001c: 03 7f                      |   loop i32
  00001e: 41 02                      |     i32.const 2
  000020: 04 7f                      |     if i32
  000022: 41 03                      |       i32.const 3
  000024: 05                         |     else
  000025: 41 04                      |       i32.const 4
  000027: 0b                         |     end
  000028: 0b                         |   end
  000029: 1a                         |   drop
  00002a: 0b                         | end
  00002b: 0b                         | end
  ```

### 1.4.5 跳转指令
- 共 4 条指令如下

  指令 | 操作码| 作用 | 立即数
  ----|----|----|-------
  `br` | 0x0C | 无条件跳转 | 目标标签索引
  `br_if` | 0x0D | 有条件跳转 | 目标标签索引
  `br_table` | 0x0E | 查表跳转 | 目标标签索引表和默认标签索引
  `return` | 0x0F | 直接跳出最外层循环并导致整个函数返回 | N/A
  目标标签索引表: vec<label>
  默认标签索引: default # u32类型

- 具体例子
  ```
    (module
    (func
      (block
        (block
          (block
            (br 1)
            (br_if 2 (i32.const 100))
            (br_table 0 1 2 3)
            (return)
          )
        )
      )
    )
  )
  ```

- 二进制分析
  ```bash
  wat2wasm 05-break.wat 
  wasm-objdump -d 05-break.wasm 

  05-break.wasm:	file format wasm 0x1

  Code Disassembly:

  000016 func[0]:
  000017: 02 40                      | block
  000019: 02 40                      |   block
  00001b: 02 40                      |     block
  00001d: 0c 01                      |       br 1
  00001f: 41 e4 00                   |       i32.const 100
  000022: 0d 02                      |       br_if 2
  000024: 0e 03 00 01 02 03          |       br_table 0 1 2 3
  00002a: 0f                         |       return
  00002b: 0b                         |     end
  00002c: 0b                         |   end
  00002d: 0b                         | end
  00002e: 0b                         | end
  ```

### 1.4.6 函数调用指令
- 两种函数调用方式
  - `call`（操作码 0x10）进行直接函数调用，函数索引由立即数指定
  - `call_indirect`（操作码 0x11）进行间接函数调用，函数签名的签名由立即数指定，到运行时才能知道具体调用的函数
- 编码格式

  ```
     call_instr: 0x10|func_idx
  call_indirect: 0x11|type_idx|0x00
  ```
- 间接函数调用指令需要查表才能完成，由第 2 个立即数指定查哪张表。目前由于模块最多只能导入或定义一张表，所以这个立即数只起到占位作用，必须为 0
- 二进制分析
  ```bash
  wat2wasm 06-call.wat 
  wasm-objdump -d 06-call.wasm 

  06-call.wasm:	file format wasm 0x1

  Code Disassembly:

  00002b func[0]:
  00002c: 10 00                      | call 0
  00002e: 41 02                      | i32.const 2
  000030: 11 01 00                   | call_indirect 1 0
  000033: 0b                         | end
  ```

### 1.4.6 其他指令
前面章节没有介绍指令和表达式解码逻辑，包括
- 全局项的初始化表达式
- 元素和数据项的偏移量表达式
- 代码项的字节码

其编码格式如下

```
global: global_type|init_expr
  elem: table_idx|offset_expr|vec<func_idx>
  data: mem_idx|offset_expr|vec<byte>
  code: byte_count|vec<locals>|expr
  expr: instr*|0x0b
```

##### 1.1.1.1 wabt观察二进制格式
```bash
// dump wasm模块所有信息
wasm-objdump -x *.wasm

```

# 2. Python 
## 2.1 Python源码剖析
