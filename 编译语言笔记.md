
# 1. WebAssembly 
## 1.1 wasm 概述 
wasm模块有三种格式，前两种是熟知的wasm和wat格式，而第三种为内存(in-memory)格式，Wasm实现(如解释器)通常会把二进制模块解码为内部形式(即内存格式，比如C/C++/Go结构体)，然后再进行后续处理。
<div align=center>
 <img src="./assets/PL/3.22-1.png"></img>
 <div>wasm三种格式之间关系</div>
</div>

从语义上讲，wasm模块从二进制格式到最终被执行可分为3个阶段：解码、验证、执行。解码阶段将二进制模块解码为内存格式；验证阶段对模块进行静态分析，确保模块的结构满足规范要求；执行阶段分为实例化和函数调用两个阶段。
<div align=center>
 <img src="./assets/PL/3.22-2.png"></img>
 <div>wasm模块语义执行阶段</div>
</div>

## 1.2 wasm 二进制格式
wasm规范一共定义了12种段，每种段都有一个ID，0-11，除了自定义段，其他段都只能最多出现一次，且出现顺序严格按照ID顺序(是因为很多段与段之间有依赖关系，只有知道前者的信息，后者才能解析，wasm二进制格式设计原则之一就是(One-Pass)一遍完成模块解析、验证和编译，即**可流式处理**)。
<div align=center>
 <img src="./assets/PL/3.22-3.png" width="60%"></img>
 <div>
    <img src="./assets/PL/3.23-1.png" width="60%"></img>
 </div>
 <div>wasm二进制格式总体结构</div>
</div>

**类型段(Type Section) ID : 1**
存储wasm模块用到的所有的类型，大部分是函数类型(函数签名)。
**导入段和导出段(Import and Export Section) ID : 2/7**
存储wasm模块中所有的导入和导出项，多个模块可以通过导入导出项链接在一起。
**函数段和代码段(Function and Code Section) ID : 3/10**
内部函数信息被分开存储在这两个段中，函数段是一个索引表，列出内部函数对应的签名索引；代码段存储内部函数的局部变量信息和字节码。
**表段和元素段(Table and Element Section) ID : 4/9**
表段列出模块内定义的所有表，元素段列出表初始化数据。wasm规范规定模块最多只能导入或定义一张表，表内容和间接函数调用有关。
**内存段和数据段(Memory and Data Section) ID : 5/11**
内存段列出模块内定义的所有内存，数据段列出内存初始化数据。wasm规范规定模块最多只能导入或定义一块内存。
**全局段(Global Section) ID : 6**
该段列出模块内定义的所有全局变量信息，包括值类型、可变性(Mutability)和初始值。
**起始段(Start Section) ID : 8**
该段给出模块的起始函数索引，起始函数主要两个作用，一个是模块加载后进行一些初始化工作，另一个是把模块变成可执行程序。
**自定义段(Custom Section) ID : 0**
该段给编译器等工具使用，可以存放函数名等调试信息，或者其他附加信息。自定义段与wasm语义无关，完全忽略也不会影响执行。

**wasm二进制编码格式**
为了让wasm二进制格式尽可能紧凑，段的字节数、各种索引等整数值都是按照**LEB128**格式编码后存储的。
**LEB128**是一种变长编码格式(variable-length code)。i32编码后可能为1-5byte，i64编码后可能1-10byte。越小的整数，编码后占用字节数就越少。
- 采用小端编码，低位字节在前
- 采用128进制，每7bit为一组，由一字节的第七位承载，空出来的最高位是标志位，1表示还有后续字节，0表示没有。
- LEB128无符号整数编码小于128的整数编码后是他本身，因为只有一字节，首位就为0
- LEB128有两种变体，分别用来编码无符号整数和有符号整数
**LEB128解码** 
<div align=center>
<div>
 <img src="./assets/PL/3.24-1.png" ></img>
</div>
 <div>LEB128无符号整数解码</div>
<div>
 <img src="./assets/PL/3.24-2.png" ></img>
</div>
 <div>LEB128有符号整数解码</div>
</div>
判断字节个数、反转字节顺序、去掉最高位字节，只有最后一个字节的处理方式不同，最后一字节的第二高位是符号位，1表示负数，需要最高位全部补1，0为正数，最高位全补0。
放眼整个wasm二进制格式，建立基本类型对照。
<div align=center>
 <img src="./assets/PL/3.24-3.png" ></img>
 <div>wasm基本类型映射表</div>
</div>

### 1.2.1 类型段

- Wasm 二进制的每个段都以 1 字节的段 ID 开始
- 段的统一编码格式如下
  ```
  sec: id|byte_count|byte+   # byte_count 有助于跳过某些段
  byte_count: u32            # LEB128 编码的 32 位无符号整数
  ```
- 大部分段可以包含多个项目，以**向量**结构编码，用 `vec<T>` 表示，具体编码方式为：先记录项目数量，然后再依次记录每个项目，**如果项目数为00，则后面项目也不需记录占字节了**。
- 借助向量表示法，段编码格式可简写为 `id|vec<byte>`，**后续部分会多次沿用这种简写格式**。
- 类型段的编码格式
  ```
  type_count: u32            # LEB128 编码的 32 位无符号整数
  type_sec:  0x01|byte_count|vec<func_type>
  vec<func_type>:  type_count|func_type+
  func_type: 0x60|vec<val_type>|vec<val_type> # 第一个 vec 表示参数列表，第二个 vec 表示结果列表
  ```
### 1.2.2 导入段
- 模块可以导出 4 种类型成员：函数、表、内存和全局变量，也可以从其他模块导入这 4 种成员
- 借助导入和导出串联多个模块，完成复杂功能
- 导入段的每项需要给出以下信息
  - 模块名
  - 成员名
  - 具体描述信息
- 导入段的编码格式如下
  ```
  import_sec: 0x02|byte_count|vec<import>
  # module_name 和 member_name 可以是任意 UTF-8 编码的字符串，以 vec<byte> 形式存储
  import:     module_name|member_name|import_desc
  module_name,member_name : length_int | byte+
  # tag={0 ： "函数", 1 : "表", 2 : "内存", 3 : "全局变量"}，作为区分导入的四种类型成员，下面方括号表示只出现其中一个元素
  import_desc: tag|[type_idx, table_type, mem_type, global_type]
  type_idx : u32
  ```

### 1.2.3 函数段
- 编码格式
  ```
  func_sec: 0x03|byte_count|vec<type_idx>
  ```


 ### 1.2.4 表段
- Wasm 规范目前规定模块最多只能定义一张表，且元素类型必须为函数引用（编码为 0x70）
- 除了元素类型，表还需要指定元素数量的限制，包括**必须的下限**和**可选的上限**
- 编码格式如下
  ```
   table_sec: 0x04|byte_count|vec<table_type> # 目前 vec 长度必须为 1
  table_type: 0x70|limits
  # tag为0，则指定下限 tag为1，则上下限都要指定
      limits: tag|min|max?
  ```

### 1.2.4 内存段 
- Wasm 规范规定模块最多只能定义一块内存
- 内存只需指定内存页数限制
- 编码格式如下
  ```
   mem_sec: 0x50|byte_count|vec<mem_type> # 目前 vec 长度只能是 1
  mem_type: limits
    limits: tag|min|max?
  ```

### 1.2.5 全局段 
- 全局段列出模块内定义的所有全局变量，全局项需要指定全局变量的类型（包括值类型和可变性）以及初始值
- 编码格式如下
  ```
   global_sec: 0x06|byte_count|vec<global>
       global: global_type|init_expr
          mut: u32 # (1 可变，0 不可变)
  global_type: val_type|mut
         expr: byte*|0x0B
  ```

### 1.2.6 导出段 
- 导出段列举模块的所有导出成员，只有被导出的成员才能被外界访问
- 编码格式如下
  ```
   export_sec: 0x07|byte_count|vec<export>
       export: name|export_desc
  export_desc: tag|[func_idx, table_idx, mem_idx, global_idx]
  ```

### 1.2.7 起始段 
- 编码格式如下
  ```
  start_sec: 0x08|byte_count|func_idx
  ```

### 1.2.8 元素段 
- 每个元素项包含3部分信息：表索引（初始化哪张表）、表内偏移量（从哪里开始初 始化）、函数索引列表（给定的初始数据）
- 编码格式如下
  ```
  elem_sec: 0x09|byte_count|vec<elem>
      elem: table_idx|offset_expr|vec<func_idx> # 目前 table_idx 只能为 0
  ```

### 1.2.9 代码段
- 存放函数的字节码和方法的局部变量
- 为了节约空间，局部变量信息是压缩后存储的：连续多个相同类型的局部变量会被分为一组，统一记录变量数量和类型
- 注意：每个代码项都以该项所占字节数开头，以便于 Wasm 实现并行处理（例如，验证、分析和编译等）函数字节码
- 编码格式如下
  ```
  code_sec: 0x0A|byte_count|vec<code>
      code: byte_count|vec<locals>|expr
    locals: local_count|val_type
  ```

### 1.2.10 数据段
- 数据段 vs 元素段
  - 元素段存放表初始化数据，数据段存放内存初始化数据
  - 数据项包含三部分信息：内存索引、内存偏移量、初始数据
  - 目前模块最多只能导入或定义一块内存，所以内存索引必须为 0
  - 内存偏移量也由表达式指定
- 编码格式
  ```
  data_sec: 0x0B|byte_count|vec<data>
      data: mem_idx|offset_expr|vec<byte>
  ```

### 1.2.11 自定义段
- 相对于其他段，自定义段有两点不同
  - 不参与模块语义
  - 可以出现在任意非自定义段前后，且次数不限
- Wasm 规范要求自定义段必须以一个字符串开头，标识自定义段
- Wasm 规范在附录 7.4 定义了一个标准的自定义段，名为 `name`，专门用于存放模块名、内部函数名和局部变量名
- 编码格式如下
  ```
  custom_sec: 0x00|byte_count|name|namedata
  namedata: modulenamesubsec?|funcnamesubsec?|localnamesubsec?
  modulenamesubsec: 0x00|byte_count|modulename
  funcnamesubsec: 0x01|byte_count|namemap
  namemap: vec<nameassoc>
  nameassoc: idx|name
  localnamesubsec: 0x02|byte_count|indirectnamemap
  indirectnamemap: vec<indirectnameassoc>
  indirectnameassoc: idx|namemap
  ```

## 1.3 wasm指令集格式
wasm二进制模块中的代码(代码段中的函数代码，全局段中的初始值表达式，元素和数据段中的偏移量表达式)也是由一条一条指令构成。

wasm指令包括两部分信息：
- 操作码(opcode) : 指令的ID，决定指令将执行的操作
- 操作数(operands) : 指令的参数，决定指令执行的结果
  
### 1.3.1 操作码 
wasm指令的操作码固定为一个字节， 因此指令最多有256种。wasm共178条指令，大致分为五类：
- 控制指令，13条
- 参数指令，2条
- 变量指令，5条
- 内存指令，25条
- 数值指令，133条
  - 常量指令
  - 测试指令
  - 比较指令
  - 算术运算指令
  - 类型转换指令

<div align=center>
 <img src="./assets/PL/3.25-1.png" ></img>
 <div>wasm指令集操作码分布图</div>
</div>

**助记符**
- 为了方便开发者书写和理解，wasm 规范为每个操作码定义了助记符（Mnemonic）
- 两条命名规则
  - 类型前缀：数值指令的前缀通常为 `i32`、`i64`、`f32`、`f64`，例如，`i32.load`
  - 符号后缀
    - 如果整数指令的结果不受符号影响，则操作码助记符无特别后缀，例如，`i32.add`
    - 否则指令决定将整数解释为有符号（操作码助记符以 `_s` 结尾）还是无符号（操作码助记符以 `_u` 结尾），两者一般成对出现，例如 `i64.div_s`<->`i64.div_u`

**立即数**
- 为了方便开发者书写和理解，wasm 规范为每个操作码定义了助记符（Mnemonic）
- 两条命名规则
  - 类型前缀：数值指令的前缀通常为 `i32`、`i64`、`f32`、`f64`，例如，`i32.load`
  - 符号后缀
    - 如果整数指令的结果不受符号影响，则操作码助记符无特别后缀，例如，`i32.add`
    - 否则指令决定将整数解释为有符号（操作码助记符以 `_s` 结尾）还是无符号（操作码助记符以 `_u` 结尾），两者一般成对出现，例如 `i64.div_s`<->`i64.div_u`

### 1.3.2 立即数

- 操作数分为两种
  - **静态操作数**
    - 直接编码在指令里，跟在操作码后面
    - 又称为指令的**静态立即参数**（Static Immediate Arguments），简称**立即数**
  - **动态操作数**：在运行时从操作数栈获取。后续部分如无特别说明，操作数特指动态操作数
- 立即数大致分为
  - 数值（包括常量和索引）
  - 内存指令参数
  - 控制指令参数
- 内存指令：内存加载/存储系列指令需要指定内存偏移量和对齐提示
- `block` 和 `loop` 指令
  - wasm 使用 `block`、`loop` 和 `if` 这三种指令定义顺序、循环和分支结构的起点，均以 `end` 指令为终点，形成内部是嵌套的指令序列
  - `br` 系列指令可跳出 `block` 和 `if` 块，或者重新开始 `loop` 块
  - **多返回值提案接受前**，块最多只有一个结果，其类型用一个字节表示（0x7F->`i32`，0x7E->`i64`，0x7D->`f32`，0x7C->`f64`，`0x40`->`void`）
  - **多返回值提案接受后**，块类型被重新解释为 LEB128 有符号整数
    - 负数：-1、-2、-3、-4 和 -64 分别对应限制放开前的 5 种结果
    - 非负数：必须是有效的类型索引（**块类型也存在类型段**）
- `if` 指令类似 `block` 指令，只是需要额外考虑 `else` 分支
- `br_table` 指令
  - `br` 系列指令包括 4 条：`br`、`br_if`、`br_table` 和 `return`
  - `return` 没有立即数
  - `br` 和 `br_if` 指令的立即数是索引类型
  - `br_table` 的立即数包括一个跳转表和默认跳转标签，类似 Go 语言的 `switch`

### 1.3.3 操作数
- wasm 规范实际上定义了一台概念上的**栈式虚拟机**。绝大多数的 wasm 指令都是基于这个栈式虚拟机工作：从栈顶弹出若干个数，进行计算，然后把结果压栈
- 运行时位于栈顶并被指令操纵的数叫做指令的**动态操作数**，简称**操作数**。相应地，这个栈称为**操作数栈**。为了实现控制指令，wasm还需要一个控制栈。
- 由于采用了栈式虚拟机，大部分 wasm 指令（特别是数值指令）都很短，只有一个操作码，因为操作数都已隐含在栈上。

> Python 和 Ruby 等语言也用栈式虚拟机。Lua 和 Android 早期的 Dalvik 虚拟机采用的是寄存器虚拟机，其指令需要包含寄存器索引，所以寄存器虚拟机的指令一般较长。

## 1.4 wasm指令分析

### 1.4.1 数值指令
- 4 条常量指令和8条饱和截断指令
  - `i32.const`/`i64.const` 带 `s32`/`s64` 类型的立即数，使用 LEB128 有符号编码
  - `f32.const`/`f64.const` 带 `f32`/`f64` 类型的立即数，固定占用 4/8 字节
  - `trunc_sat`（操作码 0xFC）：格式为`前缀操作码（0xFC）+ 子操作码`，带一个单字节的子操作码作为立即数
  
- 编码格式
  ```
  i32.const: 0x41|s32
  i64.const: 0x42|s64
  f32.const: 0x43|f32
  f64.const: 0x44|f64
  trunc_sat: 0xfc|byte
  num_instr: opcode
  ```

- 二进制分析
```bash
  wat2wasm 01-numeric.wat 
  wasm-objdump -d 01-numeric.wasm 

  01-numeric.wasm:	file format wasm 0x1

  Code Disassembly:

  000016 func[0]:
  000017: 43 cd cc 44 41             | f32.const 0x1.89999ap+3   # 12.3
  00001c: 43 66 66 36 42             | f32.const 0x1.6cccccp+5   # 45.6
  000021: 92                         | f32.add
  000022: fc 00                      | i32.trunc_sat_f32_s
  000024: 1a                         | drop
  000025: 0b                         | end
```

### 1.4.2 变量指令
- 变量指令共 5 条
  - 3 条用于读写局部变量，立即数是局部变量索引，用的是LEB128无符号整数编码
  - 2 条用于读写全局变量，立即数是全局变量索引
- 编码格式
  ```
   local.get:  0x20|local_idx
   local.set:  0x21|local_idx
   local.tee:  0x22|local_idx
  global.get: 0x23|global_idx
  global.set: 0x24|global_idx
  ```

- 二进制分析
```bash
  wat2wasm 02-variable.wat 
  wasm-objdump -d 02-variable.wasm 

  02-variable.wasm:	file format wasm 0x1

  Code Disassembly:

  000025 func[0]:
  000026: 23 00                      | global.get 0    
  000028: 24 01                      | global.set 1
  00002a: 20 00                      | local.get 0
  00002c: 21 01                      | local.set 1
  00002e: 0b                         | end
```

### 1.4.3 内存指令
- 内存指令共 25 条
  - 14 条加载指令，用于将内存数据加载到操作数栈，有两个立即数：对齐提示和内存偏移量
  - 9 条存储指令，用于将操作数栈顶数据写回内存，有两个立即数：对齐提示和内存偏移量
  - 2 条指令用于获取和拓展内存页数，立即数是内存索引。wasm 规范目前规定模块只能导入或定义一块内存，所以内存索引只起到占位作用，必须为 0
- 编码格式

  ```
  load_instr: opcode|align|offset # align: u32, offset: u32
  store_instr: opcode|align|offset
  memory.size: 0x3f|0x00
  memory.grow: 0x40|0x00
  ```
- 具体例子
  ```
    (module
    (memory 1 8)
    (data (offset (i32.const 100)) "hello")

    (func
      (i32.const 1) (i32.const 2)
      (i32.load offset=100)
      (i32.store offset=100)
      (memory.size) (drop)
      (i32.const 4) (memory.grow) (drop)
    )
  )
  ```

- 二进制分析
  ```bash
  wat2wasm 03-memory.wat 
  wasm-objdump -d 03-memory.wasm 

  03-memory.wasm:	file format wasm 0x1

  Code Disassembly:

  00001c func[0]:
  00001d: 41 01                      | i32.const 1
  00001f: 41 02                      | i32.const 2
  000021: 28 02 64                   | i32.load 2 100
  000024: 36 02 64                   | i32.store 2 100
  000027: 3f 00                      | memory.size 0
  000029: 1a                         | drop
  00002a: 41 04                      | i32.const 4
  00002c: 40 00                      | memory.grow 0
  00002e: 1a                         | drop
  00002f: 0b                         | end
  ```

### 1.4.4 结构化控制指令
- 控制指令共 13 条，包括结构化控制指令、跳转指令、函数调用指令等
- 结构化控制指令有 3 条
  - `block`、`loop` 和 `if`
  - 必须和 `end` （操作码 0x0B）指令搭配，成对出现
  - 如果 `if` 指令有两条分支，则中间由 `else` 指令（操作码 0x05）分隔
  - `end` 和 `else` 也称为**伪指令**
- 编码格式

  ```
  block_instr: 0x02|block_type|instr*|0x0b
   loop_instr: 0x03|block_type|instr*|0x0b
     if_instr: 0x04|block_type|instr*|(0x05|instr*)?|0x0b
   block_type: s32
  ```
- 具体例子
  ```
    (module
    (func (result i32)
      (block (result i32)
        (i32.const 1)
        (loop (result i32)
          (if (result i32)
            (i32.const 2)
            (then (i32.const 3))
            (else (i32.const 4))
          )
        )
        (drop)
      )
    )
  )
  ```

- 二进制分析
  ```bash
  wat2wasm 04-block.wat 
  wasm-objdump -d 04-block.wasm 

  04-block.wasm:	file format wasm 0x1

  Code Disassembly:

  000017 func[0]:
  000018: 02 7f                      | block i32
  00001a: 41 01                      |   i32.const 1
  00001c: 03 7f                      |   loop i32
  00001e: 41 02                      |     i32.const 2
  000020: 04 7f                      |     if i32
  000022: 41 03                      |       i32.const 3
  000024: 05                         |     else
  000025: 41 04                      |       i32.const 4
  000027: 0b                         |     end
  000028: 0b                         |   end
  000029: 1a                         |   drop
  00002a: 0b                         | end
  00002b: 0b                         | end
  ```

### 1.4.5 跳转指令
- 共 4 条指令如下

  指令 | 操作码| 作用 | 立即数
  ----|----|----|-------
  `br` | 0x0C | 无条件跳转 | 目标标签索引
  `br_if` | 0x0D | 有条件跳转 | 目标标签索引
  `br_table` | 0x0E | 查表跳转 | 目标标签索引表和默认标签索引
  `return` | 0x0F | 直接跳出最外层循环并导致整个函数返回 | N/A
  目标标签索引表: vec<label>
  默认标签索引: default # u32类型

- 具体例子
  ```
    (module
    (func
      (block
        (block
          (block
            (br 1)
            (br_if 2 (i32.const 100))
            (br_table 0 1 2 3)
            (return)
          )
        )
      )
    )
  )
  ```

- 二进制分析
  ```bash
  wat2wasm 05-break.wat 
  wasm-objdump -d 05-break.wasm 

  05-break.wasm:	file format wasm 0x1

  Code Disassembly:

  000016 func[0]:
  000017: 02 40                      | block
  000019: 02 40                      |   block
  00001b: 02 40                      |     block
  00001d: 0c 01                      |       br 1
  00001f: 41 e4 00                   |       i32.const 100
  000022: 0d 02                      |       br_if 2
  000024: 0e 03 00 01 02 03          |       br_table 0 1 2 3
  00002a: 0f                         |       return
  00002b: 0b                         |     end
  00002c: 0b                         |   end
  00002d: 0b                         | end
  00002e: 0b                         | end
  ```

### 1.4.6 函数调用指令
- 两种函数调用方式
  - `call`（操作码 0x10）进行直接函数调用，函数索引由立即数指定
  - `call_indirect`（操作码 0x11）进行间接函数调用，函数签名的签名由立即数指定，到运行时才能知道具体调用的函数
- 编码格式

  ```
     call_instr: 0x10|func_idx
  call_indirect: 0x11|type_idx|0x00
  ```
- 间接函数调用指令需要查表才能完成，由第 2 个立即数指定查哪张表。目前由于模块最多只能导入或定义一张表，所以这个立即数只起到占位作用，必须为 0
- 二进制分析
  ```bash
  wat2wasm 06-call.wat 
  wasm-objdump -d 06-call.wasm 

  06-call.wasm:	file format wasm 0x1

  Code Disassembly:

  00002b func[0]:
  00002c: 10 00                      | call 0
  00002e: 41 02                      | i32.const 2
  000030: 11 01 00                   | call_indirect 1 0
  000033: 0b                         | end
  ```

### 1.4.6 其他指令
前面章节没有介绍指令和表达式解码逻辑，包括
- 全局项的初始化表达式
- 元素和数据项的偏移量表达式
- 代码项的字节码

其编码格式如下

```
global: global_type|init_expr
  elem: table_idx|offset_expr|vec<func_idx>
  data: mem_idx|offset_expr|vec<byte>
  code: byte_count|vec<locals>|expr
  expr: instr*|0x0b
```

##### 1.1.1.1 wabt观察二进制格式
```bash
// dump wasm模块所有信息
wasm-objdump -x *.wasm

```

# 2. Python 
## 2.1 Python源码剖析
### 2.1.1 对象模型
**一切皆对象**
Python是一门面向对象语言，实现了一个完整的面向对象系统，在Python的对象模型世界，**一切皆对象**，**基本类型也是对象**，python所有基本类型内部均由对象实现。一个整数，一个字符串都是对象。
python中的类型也是一种对象，称为**类型对象**。
```python
>>>int
<class 'int'>
```
通过整数类型实例化可以得到一个整数对象，称为**实例对象**
```python
>>>int('1024')
1024
```
面向对象理论中的“类”和“对象”在python内部都是通过对象实现的，这是python最大的特点。
<div align=center> 
<img src="./assets/PL/4.3-1.jpg" ></img>   
</div>

#### 2.1.1.1 类型、对象体系
##### 2.1.1.1.1 类型体系
**内置类型**
a是一个整数对象(实例对象)，其类型是整数类型(类型对象)：
```python
>>> a = 1
>>> type(a)  # 实例对象
<class 'int'>
>>> isinstance(a, int)  # 实例对象
True
```  
整数类型的类型则是：  
```python
>>> type(int)
<class 'type'>
```
type，即**类型的类型**，这个类型特殊，它的实例对象还是**类型对象**。
还有一个特殊类型`object`，是所有类型的基类：
```python
>>> issubclass(int, object)
True
```  
<div align=center> 
<img src="./assets/PL/4.3-2.jpg" ></img>   
</div>

**自定义类型**
```python
class Dog(object):

  def yelp(self):
    print('woof')
```
dog实例类型为Dog：
```python
>>> dog = Dog()
>>> type(dog)
<class '__main__.Dog'>
```
Dog类的类型自然也是type，其基类是object：
```python
>>> type(Dog)
<class 'type'>
>>> issubclass(Dog, object)
True
```
<div align=center> 
<img src="./assets/PL/4.3-3.jpg" ></img>   
</div>  
给出一Dog类子类Sleuth类，类型系统如下图：
<div align=center> 
<img src="./assets/PL/4.3-4.jpg" ></img>   
</div>
<br>
现在来讨论type和object这两个特殊的类型。
object是所有类型的基类，本质上也是一种类型，所以其类型必然是type。而type是所有类型的类型，其类型还是它自己。

```python
>>> type(object)
<class 'type'>
>>> type(type)
<class 'type'>
```
object是所有类型的基类，理论上也是type的基类(__base__):
```python
>>> type.__base__
<class 'object'>
```
<div align=center> 
<img src="./assets/PL/4.3-5.jpg" ></img>   
</div>
即所有类型的基类收敛于object，所有的类型的类型都是type，包括type它自己。

##### 2.1.1.1.2 变量只是名字
```python
>>> a = 1
>>> id(a)
4302704784
```
定义一个变量a，通过id内建函数取出其“地址”
定义另一个变量b，以a赋值，并取出b的“地址”
```python
>>> b = a
>>> id(b)
4302704784
```
a和b的地址相同，在python中，一切皆对象，整数也是如此，**变量只是一个与对象关联的名字**。python内部，变量只是一个名字，保存着指向实例对象的指针，进而与其绑定。变量赋值只拷贝指针，并不拷贝指针指向的对象。
<div align=center> 
<img src="./assets/PL/4.3-6.jpg" ></img>   
</div>

##### 2.1.1.1.3 可变对象与不可变对象
```python
>>> a = 1
>>> id(a)
4302704784
>>> a += 1
>>> id(a)
4302704816
```
变量a自增1之后对象直接变了(因为地址变了，变量名指向的不是一个对象了)，原因要从**可变对象**，与**不可变对象**说起。**可变对象**在对象创建后，其值可以进行修改；而**不可变对象**在对象创建后整个生命周期，其值都不可修改。
python中，整数类型是不可变类型，整数对象是不可变对象。修改整数对象时，python将以新数值创建一个新对象，并进行变量名绑定，就对象若无其他引用，将被释放。每次修改整数引发的创建新对象，释放旧对象的效率问题，将由**小整数池**等手段优化。
<div align=center> 
<img src="./assets/PL/4.3-7.jpg" ></img>   
</div>

可变对象典型例子是**列表(list)**:

```python
>>> l = [1, 2]
>>> id(l)
4385900424
>>> l.append(3)
>>> id(l)
4385900424
```
list添加元素后，地址没变。列表对象内部维护了一个**动态数组**，存储元素对象的指针：
<div align=center> 
<img src="./assets/PL/4.3-8.jpg" ></img>   
</div>

##### 2.1.1.1.4 定长对象与变长对象
标准库sys模块提供了一个`getsizeof`函数查看对象大小
```python
>>> import sys
>>> sys.getsizeof(1)
28
>>> sys.getsizeof(100000000000000000)
32
>>> sys.getsizeof(100000000000000000000000000000000000000000000)
44
```
整数对象的大小与其数值有关，像这样**大小不固定**的对象称为**变长对象**
python采用类似C++中**大整数类**的思路实现整数对象————串联多个普通32为整数，以便支持更大数值范围。**整数对象头部额外存储一些信息，记录对象用了多少个32位整数。**
```python
>>> sys.getsizeof('a')
50
>>> sys.getsizeof('abc')
52
```
字符串对象也是变长对象。
定长对象————浮点数对象float：
```python
>>> sys.getsizeof(1.)
24
>>> sys.getsizeof(1000000000000000000000000000000000.)
24
```
浮点数是由一个double实现，就算表示很大的数，浮点数对象大小也不变。64位的double牺牲了精度，来表示大范围。
```python
>>> int(1000000000000000000000000000000000.)
999999999999999945575230987042816
```

| 类别      | 特点 |
| ----------- | ----------- |
| 可变对象      | 对象创建后可以修改       |
| 不可变对象   | 对象创建后不可修改        |
| 定长对象      | 对象大小固定       |
| 变长对象   | 对象大小不固定        |

#### 2.1.1.2 深入探究对象
**PyObject，对象的基石**
在python内部，对象都由`PyObject`结构体表示，对象引用则是指针`PyObject *`。PyObject结构体定义于头文件`object.h`，路径为`Include/object.h`。
```cpp
typedef struct _object {
    _PyObject_HEAD_EXTRA
    Py_ssize_t ob_refcnt;  // 引用计数
    struct _typeobject *ob_type;  // 类型指针
} PyObject;
```
**类型指针**指向对象的类型对象，类型对象**描述实例对象的数据及行为**
_PyObject_HEAD_EXTRA 宏的定义，同样在 Include/object.h 头文件内：
```cpp
#ifdef Py_TRACE_REFS
/* Define pointers to support a doubly-linked list of all live heap objects. */
#define _PyObject_HEAD_EXTRA            \
    struct _object *_ob_next;           \
    struct _object *_ob_prev;

#define _PyObject_EXTRA_INIT 0, 0,

#else
#define _PyObject_HEAD_EXTRA
#define _PyObject_EXTRA_INIT
#endif
```
_PyObject_HEAD_EXTRA宏展开为两个指针，用来实现双向链表，双向链表用于跟踪所有**活跃堆对象**，不深入介绍。

对于**变长对象**，需要在PyObject基础上加入长度信息，即PyVarObject：
```cpp
typedef struct {
    PyObject ob_base;
    Py_ssize_t ob_size; /* Number of items in variable part */
} PyVarObject;
```
<div align=center> 
<img src="./assets/PL/4.3-9.jpg" ></img>   
</div>

**具体对象，视其大小是否固定，需要包含头部PyObject或PyVarObject。**头文件里准备了两个宏，方便其他对象使用：
```cpp
#define PyObject_HEAD          PyObject ob_base;
#define PyObject_VAR_HEAD      PyVarObject ob_base;
```
例如，对于大小固定的**浮点对象**，只需在PyObject头部基础上，用一个double加以实现：
```cpp
typedef struct {
    PyObject_HEAD

    double ob_fval;
} PyFloatObject;
```
对于大小不固定的**列表对象**，需在PyVarObject头部基础上，加一个动态数组实现，数组存储列表包含的对象，即PyObject指针：
```cpp
typedef struct {
    PyObject_VAR_HEAD  // PyVarObject中ob_size指示列表当前长度

    PyObject **ob_item;
    Py_ssize_t allocated;
} PyListObject;
```
<div align=center> 
<img src="./assets/PL/4.3-10.jpg" ></img>   
</div> 
**两个初始化对象头部的宏定义**

```cpp
#define PyObject_HEAD_INIT(type)        \
    { _PyObject_EXTRA_INIT              \
    1, type },    // 定长

#define PyVarObject_HEAD_INIT(type, size)       \
    { PyObject_HEAD_INIT(type) size },    //变长
```

**PyTypeObject，类型的基石**
描述对象支持的操作和对象所需内存空间的**元信息**，由一个独立实体保存，与对象**所属类型**密切相关。
PyObject中的ob_type指针，指向一个类型对象，元信息存在其中。PyTypeObject也在 Include/object.h 中定义。
```cpp
typedef struct _typeobject {
    PyObject_VAR_HEAD  // PyTypeObject也是个变长对象，其也含变长对象头部
    const char *tp_name; /* For printing, in format "<module>.<name>" */
    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */

    /* Methods to implement standard operations */
    destructor tp_dealloc;
    printfunc tp_print;

    getattrfunc tp_getattr;
    setattrfunc tp_setattr;

    // ...
    /* Attribute descriptor and subclassing stuff */
    struct _typeobject *tp_base;

    // ......
} PyTypeObject;
```
PyTypeObject是一个变长对象，包括变长对象头部。专有字段有：
- 类型名称 ，即 tp_name 字段；
- 类型的继承信息，例如 tp_base 字段指向基类对象；
- 创建实例对象时所需的 内存信息 ，即 tp_basicsize 和 tp_itemsize 字段；
- 该类型支持的相关 操作信息 ，即 tp_print 、 tp_getattr 等函数指针；

PyTypeObject就是**类型对象**在Python中的表现形式，对应**类**的概念。
```python
>>> float
<class 'float'>
>>> pi = 3.14
>>> e = 2.71
```
对于`pi = 3.14`代码中各个对象在内存中形式如下图：
<div align=center> 
<img src="./assets/PL/4.3-11.jpg" ></img>   
</div>  
由于浮点**类型对象**全局唯一，在 C 语言层面作为一个全局变量静态定义即可，Python 的确就这么做。 浮点类型对象就藏身于 Object/floatobject.c 中， PyFloat_Type 是也：

```cpp
PyTypeObject PyFloat_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)  // ob_type指向PyType_Type，也是个静态全局变量，类型的类型即type的对象
    "float",
    sizeof(PyFloatObject),
    0,
    (destructor)float_dealloc,                  /* tp_dealloc */

    // ...
    (reprfunc)float_repr,                       /* tp_repr */

    // ...
};
```

**PyType_Type，类型的类型**
PyType_Type 在 Object/typeobject.c 中定义：
```cpp
PyTypeObject PyType_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "type",                                     /* tp_name */
    sizeof(PyHeapTypeObject),                   /* tp_basicsize */
    sizeof(PyMemberDef),                        /* tp_itemsize */
    (destructor)type_dealloc,                   /* tp_dealloc */

    // ...
    (reprfunc)type_repr,                        /* tp_repr */

    // ...
};
```

内建类型和自定义类对应的PyTypeObject对象都是通过PyType_Type创建的。type作为**元类型**，可以被用来实现很多高级操作。
<div align=center> 
<img src="./assets/PL/4.3-12.jpg" ></img>   
</div>  

**PyBaseObject_Type，类型之基**
Object/object.c中：
```cpp
if (PyType_Ready(&PyFloat_Type) < 0)
    Py_FatalError("Can't initialize float type");
```
PyType_Ready会对创建好的PyFloat_Type静态定义后进行进一步加工，将tp_base字段初始化成PyBaseObject_Type：
```cpp
int
PyType_Ready(PyTypeObject *type)
{
    // ...

    base = type->tp_base;
    if (base == NULL && type != &PyBaseObject_Type) {
        base = type->tp_base = &PyBaseObject_Type;
        Py_INCREF(base);
    }

    // ...
}
```
PyBaseObject_Type内容：
```cpp
PyTypeObject PyBaseObject_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "object",                                   /* tp_name */
    sizeof(PyObject),                           /* tp_basicsize */
    0,                                          /* tp_itemsize */
    object_dealloc,                             /* tp_dealloc */

    // ...
    object_repr,                                /* tp_repr */
};
```
**完整的对象图**
<div align=center> 
<img src="./assets/PL/4.3-13.jpg" ></img>   
</div> 

#### 2.1.1.3 对象的生命周期
**C API**
Python提供了两种类型C API，让用户可以从C环境中与其交互。Python内部也大量使用这些API。分为**泛型API**和**特型API**。
**泛型API**
泛型API与类型无关，属于**抽象对象层**(Abstract Object Layer AOL)。这类API参数为`PyObject *`,可处理任意类型的对象，API内部根据对象类型区别处理。
```cpp
int
PyObject_Print(PyObject *op, FILE *fp, int flags)
```
以此对象打印函数为例，第一个参数为待打印对象，可以为任意类型对象，因此参数为`PyObject *`,Python内部一般都是通过`PyObject *`引用对象，以达到泛型化的目的。
```cpp
// 打印浮点对象
PyObject *fo = PyFloatObject_FromDouble(3.14);
PyObject_Print(fo, stdout, 0);

// 打印整数对象
PyObject *lo = PyFloatObject_FromLong(100);
PyObject_Print(lo, stdout, 0);
```

**特型API**
**特型API**与类型相关，属于**具体对象层(Concrete Object Layer COL)**。这类API只能作用于某种类型的对象，如浮点对象PyFloatObject。python内部为每一种内置对象提供了这样一组API，如下：
```cpp
PyObject *
PyFloat_FromDouble(double fval)  // 创建一个浮点对象，并初始化为定值fval
```
